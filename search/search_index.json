{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Next-generation developer-first NoSQL database. AnnaDB moves familiar programming languages' patterns into the databases world to solve the problem of the relations: Every object and sub-object (item of a vector or map) that was stored in AnnaDB has a link id. This link can be placed as a field value of any other object and the database will fetch and process it automatically on all the operations without additional commands in queries. Features: Flexible object structure Relations Transactions Read more in the documentation .","title":"About"},{"location":"install/","text":"Server docker run --init -p 10001 :10001 -t romanright/annadb:0.0.1 Client shell Install pip install annadb Run annadb --uri annadb://localhost:10001","title":"Install"},{"location":"install/#server","text":"docker run --init -p 10001 :10001 -t romanright/annadb:0.0.1","title":"Server"},{"location":"install/#client-shell","text":"Install pip install annadb Run annadb --uri annadb://localhost:10001","title":"Client shell"},{"location":"articles/introduction/","text":"AnnaDB","title":"AnnaDB"},{"location":"articles/introduction/#annadb","text":"","title":"AnnaDB"},{"location":"documentation/data_types/","text":"There are primitive and container data types in AnnaDB. Primitives Primitive data types are a set of basic types whose values can not be decoupled. In TySON, primitives are represented as prefix|value| or prefix only. Prefix in AnnaDB shows the data type. Type Description Prefix Example Number Integer or float point number n n | 101 | String Any string. `|` symbols must be escaped with `\\` s s | Lorem ipsum | Bool A boolean value b b | true | Null A marker that indicating that something has no value null null Unix Timestamp The number of seconds that have elapsed since the Unix epoch uts uts | 123456789 | Link Id of an object. The collection name is used for the prefix Collection name users | e0bbcda2-0911-495e-9f0f-ce00db489f10 | Containers Container data types keep primitive and container objects using specific rules. Type Description Prefix Example Vector An ordered set of elements of any type v v [ n | 1 |, n | 2 |, n | 3 |,] Map An associative array m m { s | bar |: s | baz |,}","title":"Data Types"},{"location":"documentation/data_types/#primitives","text":"Primitive data types are a set of basic types whose values can not be decoupled. In TySON, primitives are represented as prefix|value| or prefix only. Prefix in AnnaDB shows the data type. Type Description Prefix Example Number Integer or float point number n n | 101 | String Any string. `|` symbols must be escaped with `\\` s s | Lorem ipsum | Bool A boolean value b b | true | Null A marker that indicating that something has no value null null Unix Timestamp The number of seconds that have elapsed since the Unix epoch uts uts | 123456789 | Link Id of an object. The collection name is used for the prefix Collection name users | e0bbcda2-0911-495e-9f0f-ce00db489f10 |","title":"Primitives"},{"location":"documentation/data_types/#containers","text":"Container data types keep primitive and container objects using specific rules. Type Description Prefix Example Vector An ordered set of elements of any type v v [ n | 1 |, n | 2 |, n | 3 |,] Map An associative array m m { s | bar |: s | baz |,}","title":"Containers"},{"location":"documentation/delete/","text":"Remove found objects or the whole collection. Prefix: delete Value: no value. Prefix-only primitive Can start the pipeline: No Steps before: find, get, sort, limit, offset Steps after: - Example Input: collection | test |: q [ find [ gt { value | num |: n | 5 |, }, ], delete , ]; Output: result : ok [ response { s | data |: ids [ test | 4daa39d0-46d6-4962-a65b-479ceee1c765 |, test | dbe8b09f-3cb0-45f8-92fc-87e948d2ea3c |, test | de333ee9-70de-4ec0-a1ce-962adf8ccfaf |, test | 7a0309b9-5c84-4860-90d6-697a8cc1a929 |, ], s | meta |: update_meta { s | count |: n | 4 |, }, }, ];","title":"Delete"},{"location":"documentation/delete/#example","text":"Input: collection | test |: q [ find [ gt { value | num |: n | 5 |, }, ], delete , ]; Output: result : ok [ response { s | data |: ids [ test | 4daa39d0-46d6-4962-a65b-479ceee1c765 |, test | dbe8b09f-3cb0-45f8-92fc-87e948d2ea3c |, test | de333ee9-70de-4ec0-a1ce-962adf8ccfaf |, test | 7a0309b9-5c84-4860-90d6-697a8cc1a929 |, ], s | meta |: update_meta { s | count |: n | 4 |, }, }, ];","title":"Example"},{"location":"documentation/find/","text":"Find objects using comparison and logical operators Prefix: find Value: Vector of operators Can start the pipeline: Yes Steps before: find, get, sort, limit, offset Steps after: find, get, sort, limit, offset, update, delete Comparison operators Equal - eq{...} Not equal - neq{...} Greater than - gt{...} Greater than or equeal - gte{...} Less than - lt{...} Less than or equal - lte{...} Less than or equal - lte{...} Logical operators And - and[...] Or - or[...] Not - not(...) In order to compare the value of the object root path notation could be used: eq { root: s | bar | } In order to compare a field of the object path to value notation could be used: eq { value | path.to.field | : s | bar | } Example Input: collection | test |: find [ gt { value | num |: n | 4 |, }, ]; Output: result : ok [ response { s | data |: objects { test | c5b67537-50d5-49c7-9679-88e86d94978a |: m { s | num |: n | 5 |, s | name |: s | test_5 |, }, test | 7d6175fe-b36a-4035-aecb-94639bed4d4a |: m { s | num |: n | 6 |, s | name |: s | test_6 |, }, test | c4f6328a-7e80-4921-96cd-d93e0e451c4a |: m { s | num |: n | 8 |, s | name |: s | test_8 |, }, test | cc1957cf-9c5e-402d-a1f0-8bd0324fd215 |: m { s | name |: s | test_7 |, s | num |: n | 7 |, }, test | 55bd34c4-f2c1-4181-a06f-b73029330548 |: m { s | num |: n | 9 |, s | name |: s | test_9 |, }, }, s | meta |: find_meta { s | count |: n | 5 |, }, }, ];","title":"Find"},{"location":"documentation/find/#comparison-operators","text":"Equal - eq{...} Not equal - neq{...} Greater than - gt{...} Greater than or equeal - gte{...} Less than - lt{...} Less than or equal - lte{...} Less than or equal - lte{...}","title":"Comparison operators"},{"location":"documentation/find/#logical-operators","text":"And - and[...] Or - or[...] Not - not(...) In order to compare the value of the object root path notation could be used: eq { root: s | bar | } In order to compare a field of the object path to value notation could be used: eq { value | path.to.field | : s | bar | }","title":"Logical operators"},{"location":"documentation/find/#example","text":"Input: collection | test |: find [ gt { value | num |: n | 4 |, }, ]; Output: result : ok [ response { s | data |: objects { test | c5b67537-50d5-49c7-9679-88e86d94978a |: m { s | num |: n | 5 |, s | name |: s | test_5 |, }, test | 7d6175fe-b36a-4035-aecb-94639bed4d4a |: m { s | num |: n | 6 |, s | name |: s | test_6 |, }, test | c4f6328a-7e80-4921-96cd-d93e0e451c4a |: m { s | num |: n | 8 |, s | name |: s | test_8 |, }, test | cc1957cf-9c5e-402d-a1f0-8bd0324fd215 |: m { s | name |: s | test_7 |, s | num |: n | 7 |, }, test | 55bd34c4-f2c1-4181-a06f-b73029330548 |: m { s | num |: n | 9 |, s | name |: s | test_9 |, }, }, s | meta |: find_meta { s | count |: n | 5 |, }, }, ];","title":"Example"},{"location":"documentation/get/","text":"Get one or many objects by id (link) Prefix: get Value: Vector of links Can start the pipeline: Yes Steps before: find, get, sort, limit, offset Steps after: find, get, sort, limit, offset, update, delete Examples collection | test |: get [ test | 31a5d221-7598-4cda-942c-b3b8d81118e4 |, test | a66de7a4-90cc-4fba-9e8c-2e1ff43bb5e9 |, ]; Output: result : ok [ response { s | data |: objects { test | 31a5d221-7598-4cda-942c-b3b8d81118e4 |: s | foo |, test | a66de7a4-90cc-4fba-9e8c-2e1ff43bb5e9 |: s | bar |, }, s | meta |: get_meta { s | count |: n | 2 |, }, }, ];","title":"Get"},{"location":"documentation/get/#examples","text":"collection | test |: get [ test | 31a5d221-7598-4cda-942c-b3b8d81118e4 |, test | a66de7a4-90cc-4fba-9e8c-2e1ff43bb5e9 |, ]; Output: result : ok [ response { s | data |: objects { test | 31a5d221-7598-4cda-942c-b3b8d81118e4 |: s | foo |, test | a66de7a4-90cc-4fba-9e8c-2e1ff43bb5e9 |: s | bar |, }, s | meta |: get_meta { s | count |: n | 2 |, }, }, ];","title":"Examples"},{"location":"documentation/insert/","text":"Insert one or many primitive or container objects Prefix: insert Value: Vector of object Can start the pipeline: Yes Steps before: - Steps after: - Example Input: collection | test |: insert [ s | foo |, n | 100 |, b | True |, v [ n | 1 |, n | 2 |, n | 3 |, ], m { s | bar |: s | baz |, }, ]; Output: result : ok [ response { s | data |: ids [ test | 6d45f29c-a0c3-43cf-803a-151d7bf31e74 |, test | 844745ad-4eb8-41d3-8f0a-ec248b5fe0da |, test | 9f1027ed-9cc0-4fea-abab-5cf02153acb2 |, test | 6ab34d23-0d58-4c09-add5-ed8271725c38 |, test | 8ec84bb1-5b04-4fde-b316-73811cef7c68 |, ], s | meta |: insert_meta { s | count |: n | 5 |, }, }, ];","title":"Insert"},{"location":"documentation/insert/#example","text":"Input: collection | test |: insert [ s | foo |, n | 100 |, b | True |, v [ n | 1 |, n | 2 |, n | 3 |, ], m { s | bar |: s | baz |, }, ]; Output: result : ok [ response { s | data |: ids [ test | 6d45f29c-a0c3-43cf-803a-151d7bf31e74 |, test | 844745ad-4eb8-41d3-8f0a-ec248b5fe0da |, test | 9f1027ed-9cc0-4fea-abab-5cf02153acb2 |, test | 6ab34d23-0d58-4c09-add5-ed8271725c38 |, test | 8ec84bb1-5b04-4fde-b316-73811cef7c68 |, ], s | meta |: insert_meta { s | count |: n | 5 |, }, }, ];","title":"Example"},{"location":"documentation/introduction/","text":"Collections AnnaDB stores objects in collections. Collections are analogous to tables in SQL databases. Every object and sub-object (item of a vector or map) that was stored in AnnaDB has a link id. This id consists of the collection name and unique uuid4 value. One object can contain links to objects from any collections - AnnaDB will fetch and process them on all the operations automatically without additional commands (joins or lookups) TySON AnnaDB query language uses the TySON format. The main difference from other data formats is that each item has a value and prefix. The prefix can mark the data type or query type (as it is used in AnnaDB) or any other information, useful for the parser. This adds more flexibility to the data structure design - it is allowed to use as many custom data types, as the developer needs. You can read more about the TySON format here Query Query in AnnaDB is a pipeline of steps, that should be applied in the order it was declared. The steps are wrapped into a vector with the prefix q - query. collection | test |: q [ find [ ], sort [ asc ( value | num |), ], limit ( n | 5 |), ]; If the pipeline has only one step, the q vector is not needed. collection | test |: find [ gt { value | num |: n | 4 |, }, ]; Transaction Every database call is a transaction with AnnaDB. You can send as many queries as you want together in a single call. If something will go wrong in the middle, all the queries in this transaction will be rolled back. Results of all the queries will be returned together in a vector in the respective order. collection | test |: q [ find [ gt { value | num |: n | 4 |, }, ], update [ set { value | blink2.a |: n | 100 |, }, ], ]; collection | test |: q [ find [ ], update [ set { value | blink2.e |: n | 1000 |, }, ], ]; Client AnnaDB shell client is an interactive terminal application, that connects to the DB instance, validates and handles queries. It fits well to play with query language or work with the data manually. Using from your app AnnaDB has a Python driver. It has an internal query builder - you don't need to learn AnnaDB query syntax to work with it. But it supports raw querying too. LINK Other languages will be supported soon too. If you want to help me with this, please text me - I'll provide all the information and tools.","title":"Introduction"},{"location":"documentation/introduction/#collections","text":"AnnaDB stores objects in collections. Collections are analogous to tables in SQL databases. Every object and sub-object (item of a vector or map) that was stored in AnnaDB has a link id. This id consists of the collection name and unique uuid4 value. One object can contain links to objects from any collections - AnnaDB will fetch and process them on all the operations automatically without additional commands (joins or lookups)","title":"Collections"},{"location":"documentation/introduction/#tyson","text":"AnnaDB query language uses the TySON format. The main difference from other data formats is that each item has a value and prefix. The prefix can mark the data type or query type (as it is used in AnnaDB) or any other information, useful for the parser. This adds more flexibility to the data structure design - it is allowed to use as many custom data types, as the developer needs. You can read more about the TySON format here","title":"TySON"},{"location":"documentation/introduction/#query","text":"Query in AnnaDB is a pipeline of steps, that should be applied in the order it was declared. The steps are wrapped into a vector with the prefix q - query. collection | test |: q [ find [ ], sort [ asc ( value | num |), ], limit ( n | 5 |), ]; If the pipeline has only one step, the q vector is not needed. collection | test |: find [ gt { value | num |: n | 4 |, }, ];","title":"Query"},{"location":"documentation/introduction/#transaction","text":"Every database call is a transaction with AnnaDB. You can send as many queries as you want together in a single call. If something will go wrong in the middle, all the queries in this transaction will be rolled back. Results of all the queries will be returned together in a vector in the respective order. collection | test |: q [ find [ gt { value | num |: n | 4 |, }, ], update [ set { value | blink2.a |: n | 100 |, }, ], ]; collection | test |: q [ find [ ], update [ set { value | blink2.e |: n | 1000 |, }, ], ];","title":"Transaction"},{"location":"documentation/introduction/#client","text":"AnnaDB shell client is an interactive terminal application, that connects to the DB instance, validates and handles queries. It fits well to play with query language or work with the data manually.","title":"Client"},{"location":"documentation/introduction/#using-from-your-app","text":"AnnaDB has a Python driver. It has an internal query builder - you don't need to learn AnnaDB query syntax to work with it. But it supports raw querying too. LINK Other languages will be supported soon too. If you want to help me with this, please text me - I'll provide all the information and tools.","title":"Using from your app"},{"location":"documentation/limit/","text":"Limit number of found objects Prefix: limit Value: Modifier with a number Can start the pipeline: No Steps before: find, get, sort, limit, offset Steps after: find, get, sort, limit, offset, update, delete Example Input: collection | test |: q [ find [ ], sort [ asc ( value | num |), ], limit ( n | 5 |), ]; Output: result : ok [ response { s | data |: objects { test | 2e56c63e-5ccc-4849-942f-09bd36eaa553 |: m { s | name |: s | test_0 |, s | num |: n | 0 |, }, test | 7f935334-f984-46a2-925f-ffb572846c6f |: m { s | name |: s | test_1 |, s | num |: n | 1 |, }, test | 7bdb146d-2eb5-43ba-ae26-26343f4b9092 |: m { s | num |: n | 2 |, s | name |: s | test_2 |, }, test | bde81369-a473-411a-8ecd-0086e76e5e8e |: m { s | name |: s | test_3 |, s | num |: n | 3 |, }, test | 2a27f592-0221-429f-9264-e7fcf051930d |: m { s | num |: n | 4 |, s | name |: s | test_4 |, }, }, s | meta |: find_meta { s | count |: n | 5 |, }, }, ];","title":"Limit"},{"location":"documentation/limit/#example","text":"Input: collection | test |: q [ find [ ], sort [ asc ( value | num |), ], limit ( n | 5 |), ]; Output: result : ok [ response { s | data |: objects { test | 2e56c63e-5ccc-4849-942f-09bd36eaa553 |: m { s | name |: s | test_0 |, s | num |: n | 0 |, }, test | 7f935334-f984-46a2-925f-ffb572846c6f |: m { s | name |: s | test_1 |, s | num |: n | 1 |, }, test | 7bdb146d-2eb5-43ba-ae26-26343f4b9092 |: m { s | num |: n | 2 |, s | name |: s | test_2 |, }, test | bde81369-a473-411a-8ecd-0086e76e5e8e |: m { s | name |: s | test_3 |, s | num |: n | 3 |, }, test | 2a27f592-0221-429f-9264-e7fcf051930d |: m { s | num |: n | 4 |, s | name |: s | test_4 |, }, }, s | meta |: find_meta { s | count |: n | 5 |, }, }, ];","title":"Example"},{"location":"documentation/offset/","text":"Skip number of found objects Prefix: offset Value: Modifier with a number Can start the pipeline: No Steps before: find, get, sort, limit, offset Steps after: find, get, sort, limit, offset, update, delete Example Input: collection | test |: q [ find [ ], sort [ asc ( value | num |), ], offset ( n | 5 |), ]; Output: result : ok [ response { s | data |: objects { test | b3363ff8-0be0-4e5b-8277-f902f80ed241 |: m { s | name |: s | test_5 |, s | num |: n | 5 |, }, test | ab87b43f-566d-42cd-993c-049de440b3c9 |: m { s | name |: s | test_6 |, s | num |: n | 6 |, }, test | 247ca552-9312-4364-a887-e4b56736f167 |: m { s | num |: n | 7 |, s | name |: s | test_7 |, }, test | c52da909-6dea-44b5-a851-c9f7395ea4b3 |: m { s | name |: s | test_8 |, s | num |: n | 8 |, }, test | 44389079-1751-4c7a-b497-305b4fc60dc3 |: m { s | num |: n | 9 |, s | name |: s | test_9 |, }, }, s | meta |: find_meta { s | count |: n | 5 |, }, }, ];","title":"Offset"},{"location":"documentation/offset/#example","text":"Input: collection | test |: q [ find [ ], sort [ asc ( value | num |), ], offset ( n | 5 |), ]; Output: result : ok [ response { s | data |: objects { test | b3363ff8-0be0-4e5b-8277-f902f80ed241 |: m { s | name |: s | test_5 |, s | num |: n | 5 |, }, test | ab87b43f-566d-42cd-993c-049de440b3c9 |: m { s | name |: s | test_6 |, s | num |: n | 6 |, }, test | 247ca552-9312-4364-a887-e4b56736f167 |: m { s | num |: n | 7 |, s | name |: s | test_7 |, }, test | c52da909-6dea-44b5-a851-c9f7395ea4b3 |: m { s | name |: s | test_8 |, s | num |: n | 8 |, }, test | 44389079-1751-4c7a-b497-305b4fc60dc3 |: m { s | num |: n | 9 |, s | name |: s | test_9 |, }, }, s | meta |: find_meta { s | count |: n | 5 |, }, }, ];","title":"Example"},{"location":"documentation/pipelines/","text":"Query Set Query in the AnnaDB is a pipeline of steps, that should be applied for a collection. Transaction","title":"Pipelines"},{"location":"documentation/pipelines/#query-set","text":"Query in the AnnaDB is a pipeline of steps, that should be applied for a collection.","title":"Query Set"},{"location":"documentation/pipelines/#transaction","text":"","title":"Transaction"},{"location":"documentation/queries/","text":"","title":"Queries"},{"location":"documentation/sort/","text":"Sort found objects Prefix: sort Value: Vector of sort operators Can start the pipeline: No Steps before: find, get, sort, limit, offset Steps after: find, get, sort, limit, offset, update, delete Sort operators: Asc - asc(...) Desc - desc(...) Example Input: collection | test |: q [ find [ ], sort [ asc ( value | num |), ], ]; Output: result : ok [ response { s | data |: objects { test | 28f3541d-fc38-4c4e-b616-dd28f3a230fc |: m { s | num |: n | 0 |, s | name |: s | test_0 |, }, test | d877ec4e-09a9-4a28-b455-afcb3195a80f |: m { s | num |: n | 1 |, s | name |: s | test_1 |, }, test | 35e6389e-fadd-4870-8ab2-1eba61785ba7 |: m { s | num |: n | 2 |, s | name |: s | test_2 |, }, test | ad884930-5b7a-4b9e-99d4-046c9abbf9e1 |: m { s | num |: n | 3 |, s | name |: s | test_3 |, }, test | d4b5a43b-b31d-4dba-8849-8bfb89a82a7c |: m { s | name |: s | test_4 |, s | num |: n | 4 |, }, test | 52e400c8-fcad-4d27-ab61-af251b8d5370 |: m { s | num |: n | 5 |, s | name |: s | test_5 |, }, test | d34c386d-13d5-4edf-a3a3-de68e62cefc7 |: m { s | num |: n | 6 |, s | name |: s | test_6 |, }, test | dd9ee2ac-51df-4a4e-a79b-a1c2565a9f1b |: m { s | num |: n | 7 |, s | name |: s | test_7 |, }, test | 6bbec1ed-5937-4eca-96a3-d97cbde45dd3 |: m { s | num |: n | 8 |, s | name |: s | test_8 |, }, test | 266f8c2a-f4b5-4786-8dfc-ed44b2128813 |: m { s | num |: n | 9 |, s | name |: s | test_9 |, }, }, s | meta |: find_meta { s | count |: n | 10 |, }, }, ];","title":"Sort"},{"location":"documentation/sort/#example","text":"Input: collection | test |: q [ find [ ], sort [ asc ( value | num |), ], ]; Output: result : ok [ response { s | data |: objects { test | 28f3541d-fc38-4c4e-b616-dd28f3a230fc |: m { s | num |: n | 0 |, s | name |: s | test_0 |, }, test | d877ec4e-09a9-4a28-b455-afcb3195a80f |: m { s | num |: n | 1 |, s | name |: s | test_1 |, }, test | 35e6389e-fadd-4870-8ab2-1eba61785ba7 |: m { s | num |: n | 2 |, s | name |: s | test_2 |, }, test | ad884930-5b7a-4b9e-99d4-046c9abbf9e1 |: m { s | num |: n | 3 |, s | name |: s | test_3 |, }, test | d4b5a43b-b31d-4dba-8849-8bfb89a82a7c |: m { s | name |: s | test_4 |, s | num |: n | 4 |, }, test | 52e400c8-fcad-4d27-ab61-af251b8d5370 |: m { s | num |: n | 5 |, s | name |: s | test_5 |, }, test | d34c386d-13d5-4edf-a3a3-de68e62cefc7 |: m { s | num |: n | 6 |, s | name |: s | test_6 |, }, test | dd9ee2ac-51df-4a4e-a79b-a1c2565a9f1b |: m { s | num |: n | 7 |, s | name |: s | test_7 |, }, test | 6bbec1ed-5937-4eca-96a3-d97cbde45dd3 |: m { s | num |: n | 8 |, s | name |: s | test_8 |, }, test | 266f8c2a-f4b5-4786-8dfc-ed44b2128813 |: m { s | num |: n | 9 |, s | name |: s | test_9 |, }, }, s | meta |: find_meta { s | count |: n | 10 |, }, }, ];","title":"Example"},{"location":"documentation/transactions/","text":"","title":"Transactions"},{"location":"documentation/update/","text":"Update values of found objects Prefix: update Value: Vector of update operators Can start the pipeline: No Steps before: find, get, sort, limit, offset Steps after: - Operators: Inc - inc(...) Set - set(...) Example Input: collection | test |: q [ find [ gt { value | num |: n | 5 |, }, ], update [ set { value | num |: n | 1000 |, }, ], ]; Output: result : ok [ response { s | data |: ids [ test | 2e93fe8c-1144-4f1a-a400-76bf59be829f |, test | 5ff0d0ad-d1b8-4739-9a35-2c549659390e |, test | 72593720-3b13-4e06-843b-e9804bd2953b |, test | a3f43566-4443-4ad4-9ec9-087888016b24 |, ], s | meta |: update_meta { s | count |: n | 4 |, }, }, ];","title":"Update"},{"location":"documentation/update/#operators","text":"Inc - inc(...) Set - set(...)","title":"Operators:"},{"location":"documentation/update/#example","text":"Input: collection | test |: q [ find [ gt { value | num |: n | 5 |, }, ], update [ set { value | num |: n | 1000 |, }, ], ]; Output: result : ok [ response { s | data |: ids [ test | 2e93fe8c-1144-4f1a-a400-76bf59be829f |, test | 5ff0d0ad-d1b8-4739-9a35-2c549659390e |, test | 72593720-3b13-4e06-843b-e9804bd2953b |, test | a3f43566-4443-4ad4-9ec9-087888016b24 |, ], s | meta |: update_meta { s | count |: n | 4 |, }, }, ];","title":"Example"},{"location":"tutorial/native/","text":"In this tutorial I'll create a database for the candy store to show the basic AnnaDB features. Insert primitive let's start with categories. Let's represent categories as simple string objects. To do so let's insert the first one into the categories collection. Request : collection | categories |: insert [ s | sweets |, ]; collection|categories| shows on which collection the query will be applied. In our case - categories insert[...] - is a query step. You can insert one or many objects using the insert operation. s|sweets| - is the object to insert. In this case, it is a string primitive. Prefix s means that it is a string, | wrap the value of the primitive. Other primitive types could be found in the Data Types section . Response : result : ok [ response { s | data |: ids [ categories | a1028632-7799-4e2f-86b1-c531c3e83877 |, ], s | meta |: insert_meta { s | count |: n | 1 |, }, }, ]; If everything is ok, in result will be returned ok[...] vector with responses for all the transaction pipelines. Each response contains data and meta information. In our case there is only one response with a vector of ids in data and a number of inserted objects in meta Insert container Let's insert a more complicated object now - a chocolate bar. It will have fields: name price category For the category, I'll use the already created one. Request : collection | products |: insert [ m { s | name |: s | Tony's |, s | price |: n | 5.95 |, s | category |: categories | a1028632-7799-4e2f-86b1-c531c3e83877 |, }, ]; The query is similar to the previous one, but the object is not a primitive, but a map. The value of the category field is a link, that was received after the previous insert. Response : result : ok [ response { s | data |: ids [ products | 97fef360-b969-4187-9c7f-759e1051c9dc |, ], s | meta |: insert_meta { s | count |: n | 1 |, }, }, ]; The response is nearly the same as before - link in data and number of inserted objects in meta. Get object Let's retrieve the information about this chocolate bar now. I'll use the get operation for this, to the object by id Request : collection | products |: get [ products | 97fef360-b969-4187-9c7f-759e1051c9dc |, ]; This time I use the get[...] query step. Using this step you can retrieve one or many objects using object links. Response : result : ok [ response { s | data |: objects { products | 97fef360-b969-4187-9c7f-759e1051c9dc |: m { s | name |: s | Tony's |, s | price |: n | 5.95 |, s | category |: s | sweets |, }, }, s | meta |: get_meta { s | count |: n | 1 |, }, }, ]; In the response here you can see the objects{...} map, where keys are links to objects and values are objects. objects{} map keeps the order - it will return objects in the same order as they were requested in the get step, or as they were sorted by the sort step. The category was fetched automatically and the value was returned. Let's insert another chocolate bar there to have more objects in the collection: collection | products |: insert [ m { s | name |: s | Mars |, s | price |: n | 2 |, s | category |: categories | a1028632-7799-4e2f-86b1-c531c3e83877 |, }, ]; I use the same category id for this bar. Modify primitive Let's modify the category to make it more accurate. Request : collection | categories |: q [ get [ categories | a1028632-7799-4e2f-86b1-c531c3e83877 |, ], update [ set { root : s | chocolate |, }, ], ]; The query here consists of 2 steps. Get the object by link step and modify this object step. The update[...] operation is a vector of update operators. Read more about the update . Response : result : ok [ response { s | data |: ids [ categories | a1028632-7799-4e2f-86b1-c531c3e83877 |, ], s | meta |: update_meta { s | count |: n | 1 |, }, }, ]; The response of the update operation contains the ids of the updated objects as data and the number of the updated objects as meta. Let's take a look, at how this affected the chocolate objects. Request : collection | products |: find [ ]; To find objects I use the find[...] operation. It is a vector of find operators. If it is empty, all the collection objects will be returned. Response : result : ok [ response { s | data |: objects { products | 97fef360-b969-4187-9c7f-759e1051c9dc |: m { s | category |: s | chocolate |, s | name |: s | Tony's |, s | price |: n | 5.95 |, }, products | f31c5a59-a532-4477-8883-4350f6f600a6 |: m { s | name |: s | Mars |, s | category |: s | chocolate |, s | price |: n | 2 |, }, }, s | meta |: find_meta { s | count |: n | 2 |, }, }, ]; The category was changed for both products, as the category object was linked with these objects. Modify container Now I'll increase the price of the bars, where it is less than 2 Request : collection | products |: q [ find [ lt { value | price |: n | 3 |, }, ], update [ inc { value | price |: n | 2 |, }, ], ]; The find step can stay before the update step as well. All the found objects will be updated. Read more about find operation and operators here . Response : result : ok [ response { s | data |: ids [ products | f31c5a59-a532-4477-8883-4350f6f600a6 |, ], s | meta |: update_meta { s | count |: n | 1 |, }, }, ]; The response is similar to the previous one. Here is how all the products look like after update: result : ok [ response { s | data |: objects { products | 97fef360-b969-4187-9c7f-759e1051c9dc |: m { s | price |: n | 5.95 |, s | category |: s | chocolate |, s | name |: s | Tony's |, }, products | f31c5a59-a532-4477-8883-4350f6f600a6 |: m { s | category |: s | chocolate |, s | name |: s | Mars |, s | price |: n | 4 |, }, }, s | meta |: find_meta { s | count |: n | 2 |, }, }, ]; Sort objects To sort objects I'll use the sort operation against the price field Request : collection | products |: q [ find [ ], sort [ asc ( value | price |), ], ]; The sort[...] operation is a vector of sort operators - asc and desc . Sort operators are modifiers, that contain paths to the sorting value. The sort operation is not an independent step, it can stay only after find-like operations, that return objects. You can read more about sort here Response : result : ok [ response { s | data |: objects { products | f31c5a59-a532-4477-8883-4350f6f600a6 |: m { s | price |: n | 4 |, s | category |: s | chocolate |, s | name |: s | Mars |, }, products | 97fef360-b969-4187-9c7f-759e1051c9dc |: m { s | category |: s | chocolate |, s | price |: n | 5.95 |, s | name |: s | Tony's |, }, }, s | meta |: find_meta { s | count |: n | 2 |, }, }, ]; Objects in the response are sorted by price now. It is useful to use limit and offset operations together with sort. You can read about them in the documentation Delete objects You can use delete operation after any find-like step to delete all the found objects. Or it can be used independently to delete the whole collection. Request : collection | products |: q [ find [ gt { value | price |: n | 5 |, }, ], delete , ]; The delete operation is a primitive without value. Response : result : ok [ response { s | data |: ids [ products | 97fef360-b969-4187-9c7f-759e1051c9dc |, ], s | meta |: update_meta { s | count |: n | 1 |, }, }, ]; The response contains affected ids in data and the number of deleted objects in meta","title":"Native"},{"location":"tutorial/native/#insert-primitive","text":"let's start with categories. Let's represent categories as simple string objects. To do so let's insert the first one into the categories collection. Request : collection | categories |: insert [ s | sweets |, ]; collection|categories| shows on which collection the query will be applied. In our case - categories insert[...] - is a query step. You can insert one or many objects using the insert operation. s|sweets| - is the object to insert. In this case, it is a string primitive. Prefix s means that it is a string, | wrap the value of the primitive. Other primitive types could be found in the Data Types section . Response : result : ok [ response { s | data |: ids [ categories | a1028632-7799-4e2f-86b1-c531c3e83877 |, ], s | meta |: insert_meta { s | count |: n | 1 |, }, }, ]; If everything is ok, in result will be returned ok[...] vector with responses for all the transaction pipelines. Each response contains data and meta information. In our case there is only one response with a vector of ids in data and a number of inserted objects in meta","title":"Insert primitive"},{"location":"tutorial/native/#insert-container","text":"Let's insert a more complicated object now - a chocolate bar. It will have fields: name price category For the category, I'll use the already created one. Request : collection | products |: insert [ m { s | name |: s | Tony's |, s | price |: n | 5.95 |, s | category |: categories | a1028632-7799-4e2f-86b1-c531c3e83877 |, }, ]; The query is similar to the previous one, but the object is not a primitive, but a map. The value of the category field is a link, that was received after the previous insert. Response : result : ok [ response { s | data |: ids [ products | 97fef360-b969-4187-9c7f-759e1051c9dc |, ], s | meta |: insert_meta { s | count |: n | 1 |, }, }, ]; The response is nearly the same as before - link in data and number of inserted objects in meta.","title":"Insert container"},{"location":"tutorial/native/#get-object","text":"Let's retrieve the information about this chocolate bar now. I'll use the get operation for this, to the object by id Request : collection | products |: get [ products | 97fef360-b969-4187-9c7f-759e1051c9dc |, ]; This time I use the get[...] query step. Using this step you can retrieve one or many objects using object links. Response : result : ok [ response { s | data |: objects { products | 97fef360-b969-4187-9c7f-759e1051c9dc |: m { s | name |: s | Tony's |, s | price |: n | 5.95 |, s | category |: s | sweets |, }, }, s | meta |: get_meta { s | count |: n | 1 |, }, }, ]; In the response here you can see the objects{...} map, where keys are links to objects and values are objects. objects{} map keeps the order - it will return objects in the same order as they were requested in the get step, or as they were sorted by the sort step. The category was fetched automatically and the value was returned. Let's insert another chocolate bar there to have more objects in the collection: collection | products |: insert [ m { s | name |: s | Mars |, s | price |: n | 2 |, s | category |: categories | a1028632-7799-4e2f-86b1-c531c3e83877 |, }, ]; I use the same category id for this bar.","title":"Get object"},{"location":"tutorial/native/#modify-primitive","text":"Let's modify the category to make it more accurate. Request : collection | categories |: q [ get [ categories | a1028632-7799-4e2f-86b1-c531c3e83877 |, ], update [ set { root : s | chocolate |, }, ], ]; The query here consists of 2 steps. Get the object by link step and modify this object step. The update[...] operation is a vector of update operators. Read more about the update . Response : result : ok [ response { s | data |: ids [ categories | a1028632-7799-4e2f-86b1-c531c3e83877 |, ], s | meta |: update_meta { s | count |: n | 1 |, }, }, ]; The response of the update operation contains the ids of the updated objects as data and the number of the updated objects as meta. Let's take a look, at how this affected the chocolate objects. Request : collection | products |: find [ ]; To find objects I use the find[...] operation. It is a vector of find operators. If it is empty, all the collection objects will be returned. Response : result : ok [ response { s | data |: objects { products | 97fef360-b969-4187-9c7f-759e1051c9dc |: m { s | category |: s | chocolate |, s | name |: s | Tony's |, s | price |: n | 5.95 |, }, products | f31c5a59-a532-4477-8883-4350f6f600a6 |: m { s | name |: s | Mars |, s | category |: s | chocolate |, s | price |: n | 2 |, }, }, s | meta |: find_meta { s | count |: n | 2 |, }, }, ]; The category was changed for both products, as the category object was linked with these objects.","title":"Modify primitive"},{"location":"tutorial/native/#modify-container","text":"Now I'll increase the price of the bars, where it is less than 2 Request : collection | products |: q [ find [ lt { value | price |: n | 3 |, }, ], update [ inc { value | price |: n | 2 |, }, ], ]; The find step can stay before the update step as well. All the found objects will be updated. Read more about find operation and operators here . Response : result : ok [ response { s | data |: ids [ products | f31c5a59-a532-4477-8883-4350f6f600a6 |, ], s | meta |: update_meta { s | count |: n | 1 |, }, }, ]; The response is similar to the previous one. Here is how all the products look like after update: result : ok [ response { s | data |: objects { products | 97fef360-b969-4187-9c7f-759e1051c9dc |: m { s | price |: n | 5.95 |, s | category |: s | chocolate |, s | name |: s | Tony's |, }, products | f31c5a59-a532-4477-8883-4350f6f600a6 |: m { s | category |: s | chocolate |, s | name |: s | Mars |, s | price |: n | 4 |, }, }, s | meta |: find_meta { s | count |: n | 2 |, }, }, ];","title":"Modify container"},{"location":"tutorial/native/#sort-objects","text":"To sort objects I'll use the sort operation against the price field Request : collection | products |: q [ find [ ], sort [ asc ( value | price |), ], ]; The sort[...] operation is a vector of sort operators - asc and desc . Sort operators are modifiers, that contain paths to the sorting value. The sort operation is not an independent step, it can stay only after find-like operations, that return objects. You can read more about sort here Response : result : ok [ response { s | data |: objects { products | f31c5a59-a532-4477-8883-4350f6f600a6 |: m { s | price |: n | 4 |, s | category |: s | chocolate |, s | name |: s | Mars |, }, products | 97fef360-b969-4187-9c7f-759e1051c9dc |: m { s | category |: s | chocolate |, s | price |: n | 5.95 |, s | name |: s | Tony's |, }, }, s | meta |: find_meta { s | count |: n | 2 |, }, }, ]; Objects in the response are sorted by price now. It is useful to use limit and offset operations together with sort. You can read about them in the documentation","title":"Sort objects"},{"location":"tutorial/native/#delete-objects","text":"You can use delete operation after any find-like step to delete all the found objects. Or it can be used independently to delete the whole collection. Request : collection | products |: q [ find [ gt { value | price |: n | 5 |, }, ], delete , ]; The delete operation is a primitive without value. Response : result : ok [ response { s | data |: ids [ products | 97fef360-b969-4187-9c7f-759e1051c9dc |, ], s | meta |: update_meta { s | count |: n | 1 |, }, }, ]; The response contains affected ids in data and the number of deleted objects in meta","title":"Delete objects"},{"location":"tutorial/python/","text":"In this tutorial, I'll create a database for the candy store to show the basic AnnaDB features. Connect The Connection class is used to connect to the AnnaDB from annadb import Connection conn = Connection . from_connection_string ( \"annadb://localhost:10001\" ) Insert primitive let's start with categories. Let's represent categories as simple string objects. To do so let's insert the first one into the categories collection. Request : ... categories = conn [ \"categories\" ] response = categories . insert_one ( \"sweets\" ) . run () There are two insert operators - insert and insert_one . insert - operator to insert one or many objects. Response data is a list of links (ids). Meta - number of inserted items. insert_one - operator to insert a single object. Response data is a link. Let's get the inserted id ... sweets_id = response . data Insert container Let's insert a more complicated object now - a chocolate bar. It will have fields: name price category For the category, I'll use the already created one. Request : products = conn [ \"products\" ] response = products . insert_one ( { \"name\" : \"Tony's\" , \"price\" : 5.95 , \"category\" : sweets_id } ) tony_id = response . data The query is similar to the previous one, but the object is not a str, but a dict. The value of the category field is a link, that was received after the previous insert. Get object Let's retrieve the information about this chocolate bar now. There are two ways to get objects by link: get and get_one . You can pass any number of links to the get operator. It will return an ordered dict of the link-object pars. get_one operator is used to get a single object. Request : ... response = products . get_one ( tony_id ) . run () print ( response . data [ \"category\" ]) >> > sweets The category was fetched automatically and the value was returned. Let's insert another chocolate bar there to have more objects in the collection: ... response = products . insert_one ( { \"name\" : \"Mars\" , \"price\" : 2 , \"category\" : sweets_id } ) . run () mars_id = response . data I use the same category id for this bar. Modify primitive Let's modify the category to make it more accurate. Request : from annadb import Set , root categories . get ( sweets_id ) . update ( Set ({ root : \"chocolate\" })) . run () The query here consists of 2 steps. Get the object by link step and modify this object step. The root object is a pointer to the value to update. For Vector and Map object it works a starting point in the path like root.path.to.value Let's take a look, at how this affected the chocolate objects. Request : response = products . all () . run () for k , v in response . data . items (): print ( v [ \"category\" ]) >>> chocolate >>> chocolate The category was changed for both products, as the category object was linked with these objects. Modify container Now I'll increase the price of the bars, where it is less than 2 from annadb import Inc products . find ( root . price < 3 ) . update ( Inc ({ root . price : 2 })) . run () The find step can stay before the update step as well. All the found objects will be updated. Let's check the prices now: ... response = products . all () . run () for k , v in response . data . items (): print ( v [ \"name\" ], v [ \"price\" ]) >>> Tony 's 5.95 >>> Mars 4.0 Sort objects To sort objects I'll use the sort operation against the price field Request : response = products . all () . sort ( + root . price ) . run () for k , v in response . data . items (): print ( v [ \"name\" ], v [ \"price\" ]) >>> Mars 4.0 >>> Tony 's 5.95 Objects in the response are sorted by price now. It is useful to use limit and offset operations together with sort. You can read about them in the documentation Delete objects You can use the delete operation after any find-like step to delete all the found objects. Or it can be used independently to delete the whole collection. Request : products . find ( root . price < 5 ) . delete () . run ()","title":"Python"},{"location":"tutorial/python/#connect","text":"The Connection class is used to connect to the AnnaDB from annadb import Connection conn = Connection . from_connection_string ( \"annadb://localhost:10001\" )","title":"Connect"},{"location":"tutorial/python/#insert-primitive","text":"let's start with categories. Let's represent categories as simple string objects. To do so let's insert the first one into the categories collection. Request : ... categories = conn [ \"categories\" ] response = categories . insert_one ( \"sweets\" ) . run () There are two insert operators - insert and insert_one . insert - operator to insert one or many objects. Response data is a list of links (ids). Meta - number of inserted items. insert_one - operator to insert a single object. Response data is a link. Let's get the inserted id ... sweets_id = response . data","title":"Insert primitive"},{"location":"tutorial/python/#insert-container","text":"Let's insert a more complicated object now - a chocolate bar. It will have fields: name price category For the category, I'll use the already created one. Request : products = conn [ \"products\" ] response = products . insert_one ( { \"name\" : \"Tony's\" , \"price\" : 5.95 , \"category\" : sweets_id } ) tony_id = response . data The query is similar to the previous one, but the object is not a str, but a dict. The value of the category field is a link, that was received after the previous insert.","title":"Insert container"},{"location":"tutorial/python/#get-object","text":"Let's retrieve the information about this chocolate bar now. There are two ways to get objects by link: get and get_one . You can pass any number of links to the get operator. It will return an ordered dict of the link-object pars. get_one operator is used to get a single object. Request : ... response = products . get_one ( tony_id ) . run () print ( response . data [ \"category\" ]) >> > sweets The category was fetched automatically and the value was returned. Let's insert another chocolate bar there to have more objects in the collection: ... response = products . insert_one ( { \"name\" : \"Mars\" , \"price\" : 2 , \"category\" : sweets_id } ) . run () mars_id = response . data I use the same category id for this bar.","title":"Get object"},{"location":"tutorial/python/#modify-primitive","text":"Let's modify the category to make it more accurate. Request : from annadb import Set , root categories . get ( sweets_id ) . update ( Set ({ root : \"chocolate\" })) . run () The query here consists of 2 steps. Get the object by link step and modify this object step. The root object is a pointer to the value to update. For Vector and Map object it works a starting point in the path like root.path.to.value Let's take a look, at how this affected the chocolate objects. Request : response = products . all () . run () for k , v in response . data . items (): print ( v [ \"category\" ]) >>> chocolate >>> chocolate The category was changed for both products, as the category object was linked with these objects.","title":"Modify primitive"},{"location":"tutorial/python/#modify-container","text":"Now I'll increase the price of the bars, where it is less than 2 from annadb import Inc products . find ( root . price < 3 ) . update ( Inc ({ root . price : 2 })) . run () The find step can stay before the update step as well. All the found objects will be updated. Let's check the prices now: ... response = products . all () . run () for k , v in response . data . items (): print ( v [ \"name\" ], v [ \"price\" ]) >>> Tony 's 5.95 >>> Mars 4.0","title":"Modify container"},{"location":"tutorial/python/#sort-objects","text":"To sort objects I'll use the sort operation against the price field Request : response = products . all () . sort ( + root . price ) . run () for k , v in response . data . items (): print ( v [ \"name\" ], v [ \"price\" ]) >>> Mars 4.0 >>> Tony 's 5.95 Objects in the response are sorted by price now. It is useful to use limit and offset operations together with sort. You can read about them in the documentation","title":"Sort objects"},{"location":"tutorial/python/#delete-objects","text":"You can use the delete operation after any find-like step to delete all the found objects. Or it can be used independently to delete the whole collection. Request : products . find ( root . price < 5 ) . delete () . run ()","title":"Delete objects"}]}