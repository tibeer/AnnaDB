{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Next-generation developer-first NoSQL database. AnnaDB is an in-memory data store with disk persistence. It can work as the main data storage and the cache layer as well. Rust lang under the hood makes it memory-safe and fast. Features Flexible object structure - simple primitives and complicated nested containers could be stored in AnnaDB Relations - you can link any object to another, and AnnaDB will resolve this relation on finds, updates, and other operations. Transactions - out of the box Links Documentation GitHub Repo Docker Hub Discord Server","title":"About"},{"location":"#features","text":"Flexible object structure - simple primitives and complicated nested containers could be stored in AnnaDB Relations - you can link any object to another, and AnnaDB will resolve this relation on finds, updates, and other operations. Transactions - out of the box","title":"Features"},{"location":"#links","text":"Documentation GitHub Repo Docker Hub Discord Server","title":"Links"},{"location":"install/","text":"Server docker run --init -p 10001 :10001 -t romanright/annadb:0.1.0 Client shell Install pip install annadb Run annadb --uri annadb://localhost:10001 Playground Alternatively, you can try AnnaDB using the public playground connection string: annadb --uri annadb://playground.annadb.dev:10001","title":"Install"},{"location":"install/#server","text":"docker run --init -p 10001 :10001 -t romanright/annadb:0.1.0","title":"Server"},{"location":"install/#client-shell","text":"Install pip install annadb Run annadb --uri annadb://localhost:10001","title":"Client shell"},{"location":"install/#playground","text":"Alternatively, you can try AnnaDB using the public playground connection string: annadb --uri annadb://playground.annadb.dev:10001","title":"Playground"},{"location":"roadmap/","text":"the dates could be changed during the development Data Structures I plan to add more container data types to make working with different data fields more comfortable. Geo Points Geo Points are points with coordinates to represent geographical data. Graph Vertices To represent complex graph schemas graph vertices data structure will be added. Indices To search data effectively, some kinds of indexes will be implemented. B-Tree B-Tree is a classic index that helps compare, search and sort many data types effectively. Text The text index is needed to support full-text search over one or more text fields. Geo Geo index helps to use geo operations like search in the area or search the nearest point effectively. Query Some new query types and operators will be implemented to support more use cases. Projections Using projections, you will be allowed to set the output data format. Text search Text search queries are used to search large amounts of text. Geo operations To work with geo data, some geo operations will be implemented. Graph operations Graph operations help to work with graph structures. User Management User management is an essential part of the database. It will be implemented by version 1.0 too. Authentification The authentification manager checks the user credentials before giving the data access. Roles Different user roles will be supported: admin, writer, and reader. Rights Per-collection access rights could be customized for each user","title":"Road Map"},{"location":"roadmap/#data-structures","text":"I plan to add more container data types to make working with different data fields more comfortable.","title":"Data Structures"},{"location":"roadmap/#geo-points","text":"Geo Points are points with coordinates to represent geographical data.","title":"Geo Points"},{"location":"roadmap/#graph-vertices","text":"To represent complex graph schemas graph vertices data structure will be added.","title":"Graph Vertices"},{"location":"roadmap/#indices","text":"To search data effectively, some kinds of indexes will be implemented.","title":"Indices"},{"location":"roadmap/#b-tree","text":"B-Tree is a classic index that helps compare, search and sort many data types effectively.","title":"B-Tree"},{"location":"roadmap/#text","text":"The text index is needed to support full-text search over one or more text fields.","title":"Text"},{"location":"roadmap/#geo","text":"Geo index helps to use geo operations like search in the area or search the nearest point effectively.","title":"Geo"},{"location":"roadmap/#query","text":"Some new query types and operators will be implemented to support more use cases.","title":"Query"},{"location":"roadmap/#projections","text":"Using projections, you will be allowed to set the output data format.","title":"Projections"},{"location":"roadmap/#text-search","text":"Text search queries are used to search large amounts of text.","title":"Text search"},{"location":"roadmap/#geo-operations","text":"To work with geo data, some geo operations will be implemented.","title":"Geo operations"},{"location":"roadmap/#graph-operations","text":"Graph operations help to work with graph structures.","title":"Graph operations"},{"location":"roadmap/#user-management","text":"User management is an essential part of the database. It will be implemented by version 1.0 too.","title":"User Management"},{"location":"roadmap/#authentification","text":"The authentification manager checks the user credentials before giving the data access.","title":"Authentification"},{"location":"roadmap/#roles","text":"Different user roles will be supported: admin, writer, and reader.","title":"Roles"},{"location":"roadmap/#rights","text":"Per-collection access rights could be customized for each user","title":"Rights"},{"location":"articles/first/","text":"I'm excited to introduce AnnaDB - the next-generation developer-first NoSQL data store. I work with many small projects daily - proofs of concepts and experiments with new frameworks or patterns. For these purposes, I needed a database that works with flexible data structures, as I change it frequently during my experiments. And it must support relations out of the box, as this is a natural part of the structures' design - links to other objects. I tried a lot (if not all) databases, but nothing fit my requirements well. So, I decided to make my own then. This is how AnnaDB was born. AnnaDB is an in-memory data store with disk persistence. It is written with Rust, a memory-safe compilable language. AnnaDB is fast and safe enough to be and the main data storage, and the cache layer. Features Flexible object structure - simple primitives and complicated nested containers could be stored in AnnaDB Relations - you can link any object to another, and AnnaDB will resolve this relation on finds, updates, and other operations. Transactions - out of the box Basics I want to start with the basic concepts and examples of the syntax here and continue with the usage example. Collections AnnaDB stores objects in collections. Collections are analogous to tables in SQL databases. Every object and sub-object (item of a vector or map) that was stored in AnnaDB has a link (id). This link consists of the collection name and unique uuid4 value. One object can contain links to objects from any collections - AnnaDB will fetch and process them on all the operations automatically without additional commands (joins or lookups) TySON The AnnaDB query language uses the TySON format. The main difference from other data formats is that each item has a value and prefix. The prefix can mark the data or query type (as it is used in AnnaDB) or any other useful for the parser information. This adds more flexibility to the data structure design - it is allowed to use as many custom data types as the developer needs. You can read more about the TySON format here Data Types There are primitive and container data types in AnnaDB. Primitive data types are a set of basic types whose values can not be decoupled. In TySON, primitives are represented as prefix|value| or prefix only. Prefix in AnnaDB shows the data type. For example, the string test will be represented as s|test| , where s - is a prefix that marks data as a string, and test is the actual value. Container data types keep primitive and container objects using specific rules. There are only two container types in AnnaDB for now. Maps and vectors. Vectors are ordered sets of elements of any type. Example: v[n|1|,n|2|,n|3|,] Maps are associative arrays. Example: m{ s|bar|: s|baz|,} More information about AnnaDB data types can be found in the documentation Query Query in AnnaDB is a pipeline of steps that should be applied in the order it was declared. The steps are wrapped into a vector with the prefix q - query. collection | test |: q [ find [ ], sort [ asc ( value | num |), ], limit ( n | 5 |), ]; If the pipeline has only one step, the q vector is not needed. collection | test |: find [ gt { value | num |: n | 4 |, }, ]; Server To run AnnaDB locally please type the next command in the terminal: docker run --init -p 10001 :10001 -t romanright/annadb:0.1.0 Client AnnaDB shell client is an interactive terminal application that connects to the DB instance, validates and handles queries. It fits well to play with query language or work with the data manually. It can be installed via pip pip install annadb Run annadb --uri annadb://localhost:10001 Usage example You are prepared for the fun part of the article now. Let's play with AnnaDB! I'll create a database for the candy store to show the features. Insert primitive Let's start with categories. I'll represent categories as simple string objects. Let's insert the first one into the categories collection. Request : collection | categories |: insert [ s | sweets |, ]; collection|categories| shows on which collection the query will be applied. In our case - categories . insert[...] - is a query step. You can insert one or many objects using the insert operation. s|sweets| - is the object to insert. In this case, it is a string primitive. Prefix s means that it is a string, | wrap the value of the primitive. Other primitive types could be found in the Data Types section . Response : result : ok [ response { s | data |: ids [ categories | 0f673e57-58d2-4e9d-a4d7-7aeab4f2da90 |, ], s | meta |: insert_meta { s | count |: n | 1 |, }, }, ]; If everything is ok, the result will have an ok[...] vector with responses for all the transaction pipelines. Each response contains data and meta information. In our case, there is only one response with a vector of ids in data and a number of inserted objects in meta . Insert container Let's insert a more complicated object now - a chocolate bar. It will have fields: name price category For the category, I'll use the already created one. Request : collection | products |: insert [ m { s | name |: s | Tony's |, s | price |: n | 5.95 |, s | category |: categories | 0f673e57-58d2-4e9d-a4d7-7aeab4f2da90 |, }, ]; The query is similar to the previous one, but the object is not a primitive but a map. The value of the category field is a link that was received after the previous insert. Response : result : ok [ response { s | data |: ids [ products | c5df220f-0c35-4932-8541-e3d90703adea |, ], s | meta |: insert_meta { s | count |: n | 1 |, }, }, ]; The response is nearly the same as before - link in data and number of inserted objects in meta. Get object Let's retrieve the information about this chocolate bar now. I'll use the get operation for this, to the object by id Request : collection | products |: get [ products | c5df220f-0c35-4932-8541-e3d90703adea |, ]; This time I use the get[...] query step. Using this step you can retrieve one or many objects using object links. Response : result : ok [ response { s | data |: objects { products | c5df220f-0c35-4932-8541-e3d90703adea |: m { s | category |: s | sweets |, s | price |: n | 5.95 |, s | name |: s | Tony's |, }, }, s | meta |: get_meta { s | count |: n | 1 |, }, }, ]; In the response here you can see the objects{...} map, where keys are links to objects and values are objects. objects{} map keeps the order - it will return objects in the same order as they were requested in the get step, or as they were sorted by the sort step. The category was fetched automatically and the value was returned. Let's insert another chocolate bar there to have more objects in the collection: collection | products |: insert [ m { s | name |: s | Mars |, s | price |: n | 2 |, s | category |: categories | 0f673e57-58d2-4e9d-a4d7-7aeab4f2da90 |, }, ]; I use the same category id for this bar. Modify primitive Let's modify the category to make it more accurate. Request : collection | categories |: q [ get [ categories | 0f673e57-58d2-4e9d-a4d7-7aeab4f2da90 |, ], update [ set { root : s | chocolate |, }, ], ]; The query here consists of 2 steps. Get the object by link step and modify this object step. The update[...] operation is a vector of update operators. Read more about the update . Response : result : ok [ response { s | data |: ids [ categories | 0f673e57-58d2-4e9d-a4d7-7aeab4f2da90 |, ], s | meta |: update_meta { s | count |: n | 1 |, }, }, ]; The response of the update operation contains the ids of the updated objects as data and the number of the updated objects as meta. Let's take a look at how this affected the chocolate objects. Request : collection | products |: find [ ]; To find objects, I use the find[...] operation. It is a vector of find operators. If it is empty, all the collection objects will be returned. Response : result : ok [ response { s | data |: objects { products | c5df220f-0c35-4932-8541-e3d90703adea |: m { s | name |: s | Tony's |, s | category |: s | chocolate |, s | price |: n | 5.95 |, }, products | 63c38829-3c13-4e93-ad82-1c7629e83b70 |: m { s | name |: s | Mars |, s | price |: n | 2 |, s | category |: s | chocolate |, }, }, s | meta |: find_meta { s | count |: n | 2 |, }, }, ]; The category was changed for both products, as the category object was linked with these objects. Modify container Now I'll increase the price of the bars, where it is less than 2 Request : collection | products |: q [ find [ lt { value | price |: n | 3 |, }, ], update [ inc { value | price |: n | 2 |, }, ], ]; The find step can stay before the update step as well. All the found objects will be updated. Read more about find operation and operators here . Response : result : ok [ response { s | data |: ids [ products | 63c38829-3c13-4e93-ad82-1c7629e83b70 |, ], s | meta |: update_meta { s | count |: n | 1 |, }, }, ]; The response is similar to the previous one. Here is how all the products look like after the update: result : ok [ response { s | data |: objects { products | c5df220f-0c35-4932-8541-e3d90703adea |: m { s | name |: s | Tony's |, s | category |: s | chocolate |, s | price |: n | 5.95 |, }, products | 63c38829-3c13-4e93-ad82-1c7629e83b70 |: m { s | price |: n | 4 |, s | name |: s | Mars |, s | category |: s | chocolate |, }, }, s | meta |: find_meta { s | count |: n | 2 |, }, }, ]; Sort objects To sort objects, I'll use the sort operation against the price field. Request : collection | products |: q [ find [ ], sort [ asc ( value | price |), ], ]; The sort[...] operation is a vector of sort operators - asc and desc . Sort operators are modifiers that contain paths to the sorting value. The sort operation is not an independent step, it can stay only after find-like operations that return objects. You can read more about sort here Response : result : ok [ response { s | data |: objects { products | 63c38829-3c13-4e93-ad82-1c7629e83b70 |: m { s | category |: s | chocolate |, s | name |: s | Mars |, s | price |: n | 4 |, }, products | c5df220f-0c35-4932-8541-e3d90703adea |: m { s | name |: s | Tony's |, s | category |: s | chocolate |, s | price |: n | 5.95 |, }, }, s | meta |: find_meta { s | count |: n | 2 |, }, }, ]; Objects in the response are sorted by price now. It is useful to use limit and offset operations together with sort. You can read about them in the documentation Delete objects After any find-like step, you can use the delete operation to delete all the found objects. Or it can be used independently to delete the whole collection. Request : collection | products |: q [ find [ gt { value | price |: n | 5 |, }, ], delete , ]; The delete operation is a primitive without value. Response : result : ok [ response { s | data |: ids [ products | c5df220f-0c35-4932-8541-e3d90703adea |, ], s | meta |: update_meta { s | count |: n | 1 |, }, }, ]; The response contains affected ids in data and the number of deleted objects in meta . Using from your app AnnaDB has a Python driver. It has an internal query builder - you don't need to learn AnnaDB query syntax to work with it. But it supports raw querying too. Link to the PyPI repo Python tutorial I'll add drivers for other languages soon. If you can help me with it, I'll be more than happy :) Plans This is the very early version of the database. It can already do things, and I use it in a few of my projects. But there are many features to work on yet. Drivers I plan to add drivers to support the most popular languages, like JS , Rust , Go , and others. If you can help with this - please get in touch with me. Rights management This is probably the most important feature to implement. Authentication, authorizations, roles, etc. Performance increase There are many performance-related things to improve now. Query features Projections More find and update operators Developer experience improves Data Types I plan to add more data types like geo points and graph vertices to make AnnaDB more comfortable working with different data fields. Managed service My big goal is to make a managed data store service. Hey, AWS, Google Cloud, MS Azure, I'm ready for collaborations! ;) Links Documentation - https://annadb.dev GitHub Repo - https://github.com/roman-right/AnnaDB Python Driver - https://pypi.org/project/annadb/ My Twitter - https://twitter.com/roman_the_right If you face any bug or weird behavior, please, let me know.","title":"First"},{"location":"articles/first/#basics","text":"I want to start with the basic concepts and examples of the syntax here and continue with the usage example.","title":"Basics"},{"location":"articles/first/#collections","text":"AnnaDB stores objects in collections. Collections are analogous to tables in SQL databases. Every object and sub-object (item of a vector or map) that was stored in AnnaDB has a link (id). This link consists of the collection name and unique uuid4 value. One object can contain links to objects from any collections - AnnaDB will fetch and process them on all the operations automatically without additional commands (joins or lookups)","title":"Collections"},{"location":"articles/first/#tyson","text":"The AnnaDB query language uses the TySON format. The main difference from other data formats is that each item has a value and prefix. The prefix can mark the data or query type (as it is used in AnnaDB) or any other useful for the parser information. This adds more flexibility to the data structure design - it is allowed to use as many custom data types as the developer needs. You can read more about the TySON format here","title":"TySON"},{"location":"articles/first/#data-types","text":"There are primitive and container data types in AnnaDB. Primitive data types are a set of basic types whose values can not be decoupled. In TySON, primitives are represented as prefix|value| or prefix only. Prefix in AnnaDB shows the data type. For example, the string test will be represented as s|test| , where s - is a prefix that marks data as a string, and test is the actual value. Container data types keep primitive and container objects using specific rules. There are only two container types in AnnaDB for now. Maps and vectors. Vectors are ordered sets of elements of any type. Example: v[n|1|,n|2|,n|3|,] Maps are associative arrays. Example: m{ s|bar|: s|baz|,} More information about AnnaDB data types can be found in the documentation","title":"Data Types"},{"location":"articles/first/#query","text":"Query in AnnaDB is a pipeline of steps that should be applied in the order it was declared. The steps are wrapped into a vector with the prefix q - query. collection | test |: q [ find [ ], sort [ asc ( value | num |), ], limit ( n | 5 |), ]; If the pipeline has only one step, the q vector is not needed. collection | test |: find [ gt { value | num |: n | 4 |, }, ];","title":"Query"},{"location":"articles/first/#server","text":"To run AnnaDB locally please type the next command in the terminal: docker run --init -p 10001 :10001 -t romanright/annadb:0.1.0","title":"Server"},{"location":"articles/first/#client","text":"AnnaDB shell client is an interactive terminal application that connects to the DB instance, validates and handles queries. It fits well to play with query language or work with the data manually. It can be installed via pip pip install annadb Run annadb --uri annadb://localhost:10001","title":"Client"},{"location":"articles/first/#usage-example","text":"You are prepared for the fun part of the article now. Let's play with AnnaDB! I'll create a database for the candy store to show the features.","title":"Usage example"},{"location":"articles/first/#insert-primitive","text":"Let's start with categories. I'll represent categories as simple string objects. Let's insert the first one into the categories collection. Request : collection | categories |: insert [ s | sweets |, ]; collection|categories| shows on which collection the query will be applied. In our case - categories . insert[...] - is a query step. You can insert one or many objects using the insert operation. s|sweets| - is the object to insert. In this case, it is a string primitive. Prefix s means that it is a string, | wrap the value of the primitive. Other primitive types could be found in the Data Types section . Response : result : ok [ response { s | data |: ids [ categories | 0f673e57-58d2-4e9d-a4d7-7aeab4f2da90 |, ], s | meta |: insert_meta { s | count |: n | 1 |, }, }, ]; If everything is ok, the result will have an ok[...] vector with responses for all the transaction pipelines. Each response contains data and meta information. In our case, there is only one response with a vector of ids in data and a number of inserted objects in meta .","title":"Insert primitive"},{"location":"articles/first/#insert-container","text":"Let's insert a more complicated object now - a chocolate bar. It will have fields: name price category For the category, I'll use the already created one. Request : collection | products |: insert [ m { s | name |: s | Tony's |, s | price |: n | 5.95 |, s | category |: categories | 0f673e57-58d2-4e9d-a4d7-7aeab4f2da90 |, }, ]; The query is similar to the previous one, but the object is not a primitive but a map. The value of the category field is a link that was received after the previous insert. Response : result : ok [ response { s | data |: ids [ products | c5df220f-0c35-4932-8541-e3d90703adea |, ], s | meta |: insert_meta { s | count |: n | 1 |, }, }, ]; The response is nearly the same as before - link in data and number of inserted objects in meta.","title":"Insert container"},{"location":"articles/first/#get-object","text":"Let's retrieve the information about this chocolate bar now. I'll use the get operation for this, to the object by id Request : collection | products |: get [ products | c5df220f-0c35-4932-8541-e3d90703adea |, ]; This time I use the get[...] query step. Using this step you can retrieve one or many objects using object links. Response : result : ok [ response { s | data |: objects { products | c5df220f-0c35-4932-8541-e3d90703adea |: m { s | category |: s | sweets |, s | price |: n | 5.95 |, s | name |: s | Tony's |, }, }, s | meta |: get_meta { s | count |: n | 1 |, }, }, ]; In the response here you can see the objects{...} map, where keys are links to objects and values are objects. objects{} map keeps the order - it will return objects in the same order as they were requested in the get step, or as they were sorted by the sort step. The category was fetched automatically and the value was returned. Let's insert another chocolate bar there to have more objects in the collection: collection | products |: insert [ m { s | name |: s | Mars |, s | price |: n | 2 |, s | category |: categories | 0f673e57-58d2-4e9d-a4d7-7aeab4f2da90 |, }, ]; I use the same category id for this bar.","title":"Get object"},{"location":"articles/first/#modify-primitive","text":"Let's modify the category to make it more accurate. Request : collection | categories |: q [ get [ categories | 0f673e57-58d2-4e9d-a4d7-7aeab4f2da90 |, ], update [ set { root : s | chocolate |, }, ], ]; The query here consists of 2 steps. Get the object by link step and modify this object step. The update[...] operation is a vector of update operators. Read more about the update . Response : result : ok [ response { s | data |: ids [ categories | 0f673e57-58d2-4e9d-a4d7-7aeab4f2da90 |, ], s | meta |: update_meta { s | count |: n | 1 |, }, }, ]; The response of the update operation contains the ids of the updated objects as data and the number of the updated objects as meta. Let's take a look at how this affected the chocolate objects. Request : collection | products |: find [ ]; To find objects, I use the find[...] operation. It is a vector of find operators. If it is empty, all the collection objects will be returned. Response : result : ok [ response { s | data |: objects { products | c5df220f-0c35-4932-8541-e3d90703adea |: m { s | name |: s | Tony's |, s | category |: s | chocolate |, s | price |: n | 5.95 |, }, products | 63c38829-3c13-4e93-ad82-1c7629e83b70 |: m { s | name |: s | Mars |, s | price |: n | 2 |, s | category |: s | chocolate |, }, }, s | meta |: find_meta { s | count |: n | 2 |, }, }, ]; The category was changed for both products, as the category object was linked with these objects.","title":"Modify primitive"},{"location":"articles/first/#modify-container","text":"Now I'll increase the price of the bars, where it is less than 2 Request : collection | products |: q [ find [ lt { value | price |: n | 3 |, }, ], update [ inc { value | price |: n | 2 |, }, ], ]; The find step can stay before the update step as well. All the found objects will be updated. Read more about find operation and operators here . Response : result : ok [ response { s | data |: ids [ products | 63c38829-3c13-4e93-ad82-1c7629e83b70 |, ], s | meta |: update_meta { s | count |: n | 1 |, }, }, ]; The response is similar to the previous one. Here is how all the products look like after the update: result : ok [ response { s | data |: objects { products | c5df220f-0c35-4932-8541-e3d90703adea |: m { s | name |: s | Tony's |, s | category |: s | chocolate |, s | price |: n | 5.95 |, }, products | 63c38829-3c13-4e93-ad82-1c7629e83b70 |: m { s | price |: n | 4 |, s | name |: s | Mars |, s | category |: s | chocolate |, }, }, s | meta |: find_meta { s | count |: n | 2 |, }, }, ];","title":"Modify container"},{"location":"articles/first/#sort-objects","text":"To sort objects, I'll use the sort operation against the price field. Request : collection | products |: q [ find [ ], sort [ asc ( value | price |), ], ]; The sort[...] operation is a vector of sort operators - asc and desc . Sort operators are modifiers that contain paths to the sorting value. The sort operation is not an independent step, it can stay only after find-like operations that return objects. You can read more about sort here Response : result : ok [ response { s | data |: objects { products | 63c38829-3c13-4e93-ad82-1c7629e83b70 |: m { s | category |: s | chocolate |, s | name |: s | Mars |, s | price |: n | 4 |, }, products | c5df220f-0c35-4932-8541-e3d90703adea |: m { s | name |: s | Tony's |, s | category |: s | chocolate |, s | price |: n | 5.95 |, }, }, s | meta |: find_meta { s | count |: n | 2 |, }, }, ]; Objects in the response are sorted by price now. It is useful to use limit and offset operations together with sort. You can read about them in the documentation","title":"Sort objects"},{"location":"articles/first/#delete-objects","text":"After any find-like step, you can use the delete operation to delete all the found objects. Or it can be used independently to delete the whole collection. Request : collection | products |: q [ find [ gt { value | price |: n | 5 |, }, ], delete , ]; The delete operation is a primitive without value. Response : result : ok [ response { s | data |: ids [ products | c5df220f-0c35-4932-8541-e3d90703adea |, ], s | meta |: update_meta { s | count |: n | 1 |, }, }, ]; The response contains affected ids in data and the number of deleted objects in meta .","title":"Delete objects"},{"location":"articles/first/#using-from-your-app","text":"AnnaDB has a Python driver. It has an internal query builder - you don't need to learn AnnaDB query syntax to work with it. But it supports raw querying too. Link to the PyPI repo Python tutorial I'll add drivers for other languages soon. If you can help me with it, I'll be more than happy :)","title":"Using from your app"},{"location":"articles/first/#plans","text":"This is the very early version of the database. It can already do things, and I use it in a few of my projects. But there are many features to work on yet.","title":"Plans"},{"location":"articles/first/#drivers","text":"I plan to add drivers to support the most popular languages, like JS , Rust , Go , and others. If you can help with this - please get in touch with me.","title":"Drivers"},{"location":"articles/first/#rights-management","text":"This is probably the most important feature to implement. Authentication, authorizations, roles, etc.","title":"Rights management"},{"location":"articles/first/#performance-increase","text":"There are many performance-related things to improve now.","title":"Performance increase"},{"location":"articles/first/#query-features","text":"Projections More find and update operators Developer experience improves","title":"Query features"},{"location":"articles/first/#data-types_1","text":"I plan to add more data types like geo points and graph vertices to make AnnaDB more comfortable working with different data fields.","title":"Data Types"},{"location":"articles/first/#managed-service","text":"My big goal is to make a managed data store service. Hey, AWS, Google Cloud, MS Azure, I'm ready for collaborations! ;)","title":"Managed service"},{"location":"articles/first/#links","text":"Documentation - https://annadb.dev GitHub Repo - https://github.com/roman-right/AnnaDB Python Driver - https://pypi.org/project/annadb/ My Twitter - https://twitter.com/roman_the_right If you face any bug or weird behavior, please, let me know.","title":"Links"},{"location":"articles/introduction/","text":"","title":"Introduction"},{"location":"documentation/data_types/","text":"There are primitive and container data types in AnnaDB. Primitives Primitive data types are a set of basic types whose values can not be decoupled. In TySON, primitives are represented as prefix|value| or prefix only. Prefix in AnnaDB shows the data type. Type Description Prefix Example Number Integer or float point number n n | 101 | String Any string. `|` symbols must be escaped with `\\` s s | Lorem ipsum | Bool A boolean value b b | true | Null A marker that indicating that something has no value null null Unix Timestamp The number of seconds that have elapsed since the Unix epoch uts uts | 123456789 | Link Id of an object. The collection name is used for the prefix Collection name users | e0bbcda2-0911-495e-9f0f-ce00db489f10 | Containers Container data types keep primitive and container objects using specific rules. Type Description Prefix Example Vector An ordered set of elements of any type v v [ n | 1 |, n | 2 |, n | 3 |,] Map An associative array m m { s | bar |: s | baz |,}","title":"Data Types"},{"location":"documentation/data_types/#primitives","text":"Primitive data types are a set of basic types whose values can not be decoupled. In TySON, primitives are represented as prefix|value| or prefix only. Prefix in AnnaDB shows the data type. Type Description Prefix Example Number Integer or float point number n n | 101 | String Any string. `|` symbols must be escaped with `\\` s s | Lorem ipsum | Bool A boolean value b b | true | Null A marker that indicating that something has no value null null Unix Timestamp The number of seconds that have elapsed since the Unix epoch uts uts | 123456789 | Link Id of an object. The collection name is used for the prefix Collection name users | e0bbcda2-0911-495e-9f0f-ce00db489f10 |","title":"Primitives"},{"location":"documentation/data_types/#containers","text":"Container data types keep primitive and container objects using specific rules. Type Description Prefix Example Vector An ordered set of elements of any type v v [ n | 1 |, n | 2 |, n | 3 |,] Map An associative array m m { s | bar |: s | baz |,}","title":"Containers"},{"location":"documentation/delete/","text":"Remove found objects or the whole collection. Prefix: delete Value: no value. Prefix-only primitive Can start the pipeline: No Steps before: find, get, sort, limit, offset Steps after: - Example Input: collection | test |: q [ find [ gt { value | num |: n | 5 |, }, ], delete , ]; Output: result : ok [ response { s | data |: ids [ test | 728dc014-9802-484e-9ba3-14297268d189 |, test | 16e99b5a-7085-425c-a3ce-a5cf60f07bb2 |, test | fcb58259-36bb-42ad-b381-6392eb1c2a24 |, test | d38e20de-615d-4f31-b3f2-a59c25c5496f |, ], s | meta |: update_meta { s | count |: n | 4 |, }, }, ];","title":"Delete"},{"location":"documentation/delete/#example","text":"Input: collection | test |: q [ find [ gt { value | num |: n | 5 |, }, ], delete , ]; Output: result : ok [ response { s | data |: ids [ test | 728dc014-9802-484e-9ba3-14297268d189 |, test | 16e99b5a-7085-425c-a3ce-a5cf60f07bb2 |, test | fcb58259-36bb-42ad-b381-6392eb1c2a24 |, test | d38e20de-615d-4f31-b3f2-a59c25c5496f |, ], s | meta |: update_meta { s | count |: n | 4 |, }, }, ];","title":"Example"},{"location":"documentation/find/","text":"Find objects using comparison and logical operators Prefix: find Value: Vector of operators Can start the pipeline: Yes Steps before: find, get, sort, limit, offset Steps after: find, get, sort, limit, offset, update, delete Comparison operators Equal - eq{...} Not equal - neq{...} Greater than - gt{...} Greater than or equeal - gte{...} Less than - lt{...} Less than or equal - lte{...} Less than or equal - lte{...} Logical operators And - and[...] Or - or[...] Not - not(...) In order to compare the value of the object root path notation could be used: eq { root: s | bar | } In order to compare a field of the object path to value notation could be used: eq { value | path.to.field | : s | bar | } Example Input: collection | test |: find [ gt { value | num |: n | 4 |, }, ]; Output: result : ok [ response { s | data |: objects { test | 0b2e4900-65d3-4ab6-ab6d-0990f8e1e1e5 |: m { s | name |: s | test_9 |, s | num |: n | 9 |, }, test | 6dfa4b74-54e9-44b9-978e-4310a1954da1 |: m { s | num |: n | 5 |, s | name |: s | test_5 |, }, test | ebeb0680-c392-483a-b8fe-735a4ae55758 |: m { s | num |: n | 6 |, s | name |: s | test_6 |, }, test | fabe4666-8ab9-48bd-a5cf-0c3fe9f67164 |: m { s | num |: n | 7 |, s | name |: s | test_7 |, }, test | a681ed05-582a-43db-9e92-bc76c8919977 |: m { s | num |: n | 8 |, s | name |: s | test_8 |, }, }, s | meta |: find_meta { s | count |: n | 5 |, }, }, ];","title":"Find"},{"location":"documentation/find/#comparison-operators","text":"Equal - eq{...} Not equal - neq{...} Greater than - gt{...} Greater than or equeal - gte{...} Less than - lt{...} Less than or equal - lte{...} Less than or equal - lte{...}","title":"Comparison operators"},{"location":"documentation/find/#logical-operators","text":"And - and[...] Or - or[...] Not - not(...) In order to compare the value of the object root path notation could be used: eq { root: s | bar | } In order to compare a field of the object path to value notation could be used: eq { value | path.to.field | : s | bar | }","title":"Logical operators"},{"location":"documentation/find/#example","text":"Input: collection | test |: find [ gt { value | num |: n | 4 |, }, ]; Output: result : ok [ response { s | data |: objects { test | 0b2e4900-65d3-4ab6-ab6d-0990f8e1e1e5 |: m { s | name |: s | test_9 |, s | num |: n | 9 |, }, test | 6dfa4b74-54e9-44b9-978e-4310a1954da1 |: m { s | num |: n | 5 |, s | name |: s | test_5 |, }, test | ebeb0680-c392-483a-b8fe-735a4ae55758 |: m { s | num |: n | 6 |, s | name |: s | test_6 |, }, test | fabe4666-8ab9-48bd-a5cf-0c3fe9f67164 |: m { s | num |: n | 7 |, s | name |: s | test_7 |, }, test | a681ed05-582a-43db-9e92-bc76c8919977 |: m { s | num |: n | 8 |, s | name |: s | test_8 |, }, }, s | meta |: find_meta { s | count |: n | 5 |, }, }, ];","title":"Example"},{"location":"documentation/get/","text":"Get one or many objects by id (link) Prefix: get Value: Vector of links Can start the pipeline: Yes Steps before: find, get, sort, limit, offset Steps after: find, get, sort, limit, offset, update, delete Examples collection | test |: get [ test | ea63e06f-9d1c-442f-89fd-c5041d863f5f |, test | 35db29f3-eba6-4589-bf81-2542b2f5db37 |, ]; Output: result : ok [ response { s | data |: objects { test | ea63e06f-9d1c-442f-89fd-c5041d863f5f |: s | foo |, test | 35db29f3-eba6-4589-bf81-2542b2f5db37 |: s | bar |, }, s | meta |: get_meta { s | count |: n | 2 |, }, }, ];","title":"Get"},{"location":"documentation/get/#examples","text":"collection | test |: get [ test | ea63e06f-9d1c-442f-89fd-c5041d863f5f |, test | 35db29f3-eba6-4589-bf81-2542b2f5db37 |, ]; Output: result : ok [ response { s | data |: objects { test | ea63e06f-9d1c-442f-89fd-c5041d863f5f |: s | foo |, test | 35db29f3-eba6-4589-bf81-2542b2f5db37 |: s | bar |, }, s | meta |: get_meta { s | count |: n | 2 |, }, }, ];","title":"Examples"},{"location":"documentation/insert/","text":"Insert one or many primitive or container objects Prefix: insert Value: Vector of object Can start the pipeline: Yes Steps before: - Steps after: - Example Input: collection | test |: insert [ s | foo |, n | 100 |, b | true |, v [ n | 1 |, n | 2 |, n | 3 |, ], m { s | bar |: s | baz |, }, ]; Output: result : ok [ response { s | data |: ids [ test | 9e1691d3-fbd6-4444-8175-1957f2871c45 |, test | 0cc130be-c19e-47a9-892e-2905d7427dbc |, test | 87786b66-b57b-432a-a19c-2b33b2a62b90 |, test | 87da8998-923d-4050-b288-b6e7058674d3 |, test | dfb75c25-6243-4cc2-aa90-c87d4a9ef191 |, ], s | meta |: insert_meta { s | count |: n | 5 |, }, }, ];","title":"Insert"},{"location":"documentation/insert/#example","text":"Input: collection | test |: insert [ s | foo |, n | 100 |, b | true |, v [ n | 1 |, n | 2 |, n | 3 |, ], m { s | bar |: s | baz |, }, ]; Output: result : ok [ response { s | data |: ids [ test | 9e1691d3-fbd6-4444-8175-1957f2871c45 |, test | 0cc130be-c19e-47a9-892e-2905d7427dbc |, test | 87786b66-b57b-432a-a19c-2b33b2a62b90 |, test | 87da8998-923d-4050-b288-b6e7058674d3 |, test | dfb75c25-6243-4cc2-aa90-c87d4a9ef191 |, ], s | meta |: insert_meta { s | count |: n | 5 |, }, }, ];","title":"Example"},{"location":"documentation/introduction/","text":"Collections AnnaDB stores objects in collections. Collections are analogous to tables in SQL databases. Every object and sub-object (item of a vector or map) that was stored in AnnaDB has a link id. This id consists of the collection name and unique uuid4 value. One object can contain links to objects from any collections - AnnaDB will fetch and process them on all the operations automatically without additional commands (joins or lookups) TySON AnnaDB query language uses the TySON format. The main difference from other data formats is that each item has a value and prefix. The prefix can mark the data type or query type (as it is used in AnnaDB) or any other information, useful for the parser. This adds more flexibility to the data structure design - it is allowed to use as many custom data types, as the developer needs. You can read more about the TySON format here Query Query in AnnaDB is a pipeline of steps, that should be applied in the order it was declared. The steps are wrapped into a vector with the prefix q - query. collection | test |: q [ find [ ], sort [ asc ( value | num |), ], limit ( n | 5 |), ]; If the pipeline has only one step, the q vector is not needed. collection | test |: find [ gt { value | num |: n | 4 |, }, ]; Transaction Every database call is a transaction with AnnaDB. You can send as many queries as you want together in a single call. If something will go wrong in the middle, all the queries in this transaction will be rolled back. Results of all the queries will be returned together in a vector in the respective order. collection | test |: q [ find [ gt { value | num |: n | 4 |, }, ], update [ set { value | blink2.a |: n | 100 |, }, ], ]; collection | test |: q [ find [ ], update [ set { value | blink2.e |: n | 1000 |, }, ], ]; Client AnnaDB shell client is an interactive terminal application, that connects to the DB instance, validates and handles queries. It fits well to play with query language or work with the data manually. Using from your app AnnaDB has a Python driver. It has an internal query builder - you don't need to learn AnnaDB query syntax to work with it. But it supports raw querying too. LINK Other languages will be supported soon too. If you want to help me with this, please text me - I'll provide all the information and tools.","title":"Introduction"},{"location":"documentation/introduction/#collections","text":"AnnaDB stores objects in collections. Collections are analogous to tables in SQL databases. Every object and sub-object (item of a vector or map) that was stored in AnnaDB has a link id. This id consists of the collection name and unique uuid4 value. One object can contain links to objects from any collections - AnnaDB will fetch and process them on all the operations automatically without additional commands (joins or lookups)","title":"Collections"},{"location":"documentation/introduction/#tyson","text":"AnnaDB query language uses the TySON format. The main difference from other data formats is that each item has a value and prefix. The prefix can mark the data type or query type (as it is used in AnnaDB) or any other information, useful for the parser. This adds more flexibility to the data structure design - it is allowed to use as many custom data types, as the developer needs. You can read more about the TySON format here","title":"TySON"},{"location":"documentation/introduction/#query","text":"Query in AnnaDB is a pipeline of steps, that should be applied in the order it was declared. The steps are wrapped into a vector with the prefix q - query. collection | test |: q [ find [ ], sort [ asc ( value | num |), ], limit ( n | 5 |), ]; If the pipeline has only one step, the q vector is not needed. collection | test |: find [ gt { value | num |: n | 4 |, }, ];","title":"Query"},{"location":"documentation/introduction/#transaction","text":"Every database call is a transaction with AnnaDB. You can send as many queries as you want together in a single call. If something will go wrong in the middle, all the queries in this transaction will be rolled back. Results of all the queries will be returned together in a vector in the respective order. collection | test |: q [ find [ gt { value | num |: n | 4 |, }, ], update [ set { value | blink2.a |: n | 100 |, }, ], ]; collection | test |: q [ find [ ], update [ set { value | blink2.e |: n | 1000 |, }, ], ];","title":"Transaction"},{"location":"documentation/introduction/#client","text":"AnnaDB shell client is an interactive terminal application, that connects to the DB instance, validates and handles queries. It fits well to play with query language or work with the data manually.","title":"Client"},{"location":"documentation/introduction/#using-from-your-app","text":"AnnaDB has a Python driver. It has an internal query builder - you don't need to learn AnnaDB query syntax to work with it. But it supports raw querying too. LINK Other languages will be supported soon too. If you want to help me with this, please text me - I'll provide all the information and tools.","title":"Using from your app"},{"location":"documentation/limit/","text":"Limit number of found objects Prefix: limit Value: Modifier with a number Can start the pipeline: No Steps before: find, get, sort, limit, offset Steps after: find, get, sort, limit, offset, update, delete Example Input: collection | test |: q [ find [ ], sort [ asc ( value | num |), ], limit ( n | 5 |), ]; Output: result : ok [ response { s | data |: objects { test | d08412fb-9d7e-4d8f-8905-c7355a67ff70 |: m { s | num |: n | 0 |, s | name |: s | test_0 |, }, test | d261580c-1c7f-4cf0-a231-be4a25486146 |: m { s | num |: n | 1 |, s | name |: s | test_1 |, }, test | 2b908538-2ec5-4970-8a65-30f7e3f6302c |: m { s | name |: s | test_2 |, s | num |: n | 2 |, }, test | 510eb502-a645-44f4-9ea1-537682fd4049 |: m { s | name |: s | test_3 |, s | num |: n | 3 |, }, test | 12b519bd-c7b8-4124-9ba2-8647ef851900 |: m { s | num |: n | 4 |, s | name |: s | test_4 |, }, }, s | meta |: find_meta { s | count |: n | 5 |, }, }, ];","title":"Limit"},{"location":"documentation/limit/#example","text":"Input: collection | test |: q [ find [ ], sort [ asc ( value | num |), ], limit ( n | 5 |), ]; Output: result : ok [ response { s | data |: objects { test | d08412fb-9d7e-4d8f-8905-c7355a67ff70 |: m { s | num |: n | 0 |, s | name |: s | test_0 |, }, test | d261580c-1c7f-4cf0-a231-be4a25486146 |: m { s | num |: n | 1 |, s | name |: s | test_1 |, }, test | 2b908538-2ec5-4970-8a65-30f7e3f6302c |: m { s | name |: s | test_2 |, s | num |: n | 2 |, }, test | 510eb502-a645-44f4-9ea1-537682fd4049 |: m { s | name |: s | test_3 |, s | num |: n | 3 |, }, test | 12b519bd-c7b8-4124-9ba2-8647ef851900 |: m { s | num |: n | 4 |, s | name |: s | test_4 |, }, }, s | meta |: find_meta { s | count |: n | 5 |, }, }, ];","title":"Example"},{"location":"documentation/offset/","text":"Skip number of found objects Prefix: offset Value: Modifier with a number Can start the pipeline: No Steps before: find, get, sort, limit, offset Steps after: find, get, sort, limit, offset, update, delete Example Input: collection | test |: q [ find [ ], sort [ asc ( value | num |), ], offset ( n | 5 |), ]; Output: result : ok [ response { s | data |: objects { test | e44fc2bc-4cca-4401-a0c8-8f9838449366 |: m { s | num |: n | 5 |, s | name |: s | test_5 |, }, test | e51b998a-ba5c-4810-83c4-45023dde8740 |: m { s | num |: n | 6 |, s | name |: s | test_6 |, }, test | 2ebb3cb3-3140-44da-924f-81f51e8c2049 |: m { s | name |: s | test_7 |, s | num |: n | 7 |, }, test | d6f13527-32e5-447a-80f5-a4317065d2b2 |: m { s | num |: n | 8 |, s | name |: s | test_8 |, }, test | ed04c1aa-2757-4faf-bd42-c645b1fc0c69 |: m { s | num |: n | 9 |, s | name |: s | test_9 |, }, }, s | meta |: find_meta { s | count |: n | 5 |, }, }, ];","title":"Offset"},{"location":"documentation/offset/#example","text":"Input: collection | test |: q [ find [ ], sort [ asc ( value | num |), ], offset ( n | 5 |), ]; Output: result : ok [ response { s | data |: objects { test | e44fc2bc-4cca-4401-a0c8-8f9838449366 |: m { s | num |: n | 5 |, s | name |: s | test_5 |, }, test | e51b998a-ba5c-4810-83c4-45023dde8740 |: m { s | num |: n | 6 |, s | name |: s | test_6 |, }, test | 2ebb3cb3-3140-44da-924f-81f51e8c2049 |: m { s | name |: s | test_7 |, s | num |: n | 7 |, }, test | d6f13527-32e5-447a-80f5-a4317065d2b2 |: m { s | num |: n | 8 |, s | name |: s | test_8 |, }, test | ed04c1aa-2757-4faf-bd42-c645b1fc0c69 |: m { s | num |: n | 9 |, s | name |: s | test_9 |, }, }, s | meta |: find_meta { s | count |: n | 5 |, }, }, ];","title":"Example"},{"location":"documentation/pipelines/","text":"Query Set Query in the AnnaDB is a pipeline of steps, that should be applied for a collection. Transaction","title":"Pipelines"},{"location":"documentation/pipelines/#query-set","text":"Query in the AnnaDB is a pipeline of steps, that should be applied for a collection.","title":"Query Set"},{"location":"documentation/pipelines/#transaction","text":"","title":"Transaction"},{"location":"documentation/queries/","text":"","title":"Queries"},{"location":"documentation/sort/","text":"Sort found objects Prefix: sort Value: Vector of sort operators Can start the pipeline: No Steps before: find, get, sort, limit, offset Steps after: find, get, sort, limit, offset, update, delete Sort operators: Asc - asc(...) Desc - desc(...) Example Input: collection | test |: q [ find [ ], sort [ asc ( value | num |), ], ]; Output: result : ok [ response { s | data |: objects { test | 71e0c4f1-4844-42ea-b999-41c3a8a2731d |: m { s | num |: n | 0 |, s | name |: s | test_0 |, }, test | 9f5d41d7-2d7a-4912-ae23-5afe356c66e5 |: m { s | num |: n | 1 |, s | name |: s | test_1 |, }, test | 3f5cde5e-a51c-4c19-a4ef-2fe3f20df93f |: m { s | name |: s | test_2 |, s | num |: n | 2 |, }, test | 610e81a5-af78-435e-a709-0a33bb932843 |: m { s | name |: s | test_3 |, s | num |: n | 3 |, }, test | 6bf7fa4b-a58f-400c-8f2f-318d1d161ac4 |: m { s | name |: s | test_4 |, s | num |: n | 4 |, }, test | bba9ace9-8b1d-4430-ba41-e70cadff436a |: m { s | name |: s | test_5 |, s | num |: n | 5 |, }, test | b26b5d71-d6ed-464b-80bd-b919b82bf807 |: m { s | name |: s | test_6 |, s | num |: n | 6 |, }, test | f33e6db5-6c65-4bad-af1c-f956522dd284 |: m { s | num |: n | 7 |, s | name |: s | test_7 |, }, test | d00d3323-cbb5-492d-b241-85453ea38bb3 |: m { s | name |: s | test_8 |, s | num |: n | 8 |, }, test | 974239de-d6b1-4d25-9ef6-a13e731243c1 |: m { s | num |: n | 9 |, s | name |: s | test_9 |, }, }, s | meta |: find_meta { s | count |: n | 10 |, }, }, ];","title":"Sort"},{"location":"documentation/sort/#example","text":"Input: collection | test |: q [ find [ ], sort [ asc ( value | num |), ], ]; Output: result : ok [ response { s | data |: objects { test | 71e0c4f1-4844-42ea-b999-41c3a8a2731d |: m { s | num |: n | 0 |, s | name |: s | test_0 |, }, test | 9f5d41d7-2d7a-4912-ae23-5afe356c66e5 |: m { s | num |: n | 1 |, s | name |: s | test_1 |, }, test | 3f5cde5e-a51c-4c19-a4ef-2fe3f20df93f |: m { s | name |: s | test_2 |, s | num |: n | 2 |, }, test | 610e81a5-af78-435e-a709-0a33bb932843 |: m { s | name |: s | test_3 |, s | num |: n | 3 |, }, test | 6bf7fa4b-a58f-400c-8f2f-318d1d161ac4 |: m { s | name |: s | test_4 |, s | num |: n | 4 |, }, test | bba9ace9-8b1d-4430-ba41-e70cadff436a |: m { s | name |: s | test_5 |, s | num |: n | 5 |, }, test | b26b5d71-d6ed-464b-80bd-b919b82bf807 |: m { s | name |: s | test_6 |, s | num |: n | 6 |, }, test | f33e6db5-6c65-4bad-af1c-f956522dd284 |: m { s | num |: n | 7 |, s | name |: s | test_7 |, }, test | d00d3323-cbb5-492d-b241-85453ea38bb3 |: m { s | name |: s | test_8 |, s | num |: n | 8 |, }, test | 974239de-d6b1-4d25-9ef6-a13e731243c1 |: m { s | num |: n | 9 |, s | name |: s | test_9 |, }, }, s | meta |: find_meta { s | count |: n | 10 |, }, }, ];","title":"Example"},{"location":"documentation/transactions/","text":"","title":"Transactions"},{"location":"documentation/update/","text":"Update values of found objects Prefix: update Value: Vector of update operators Can start the pipeline: No Steps before: find, get, sort, limit, offset Steps after: - Operators: Inc - inc{...} Set - set{...} Example Input: collection | test |: q [ find [ gt { value | num |: n | 5 |, }, ], update [ set { value | num |: n | 1000 |, }, ], ]; Output: result : ok [ response { s | data |: ids [ test | 4339ace2-9ab3-4c79-b557-f9b78d66b7f9 |, test | 3677c916-ac4d-40ab-89f4-def1e565e7ab |, test | 5ff00377-34ac-43b9-8ebb-71bb5ff78ebf |, test | 7bdd7c8f-e9da-42f6-b473-5a6fd9a1c90f |, ], s | meta |: update_meta { s | count |: n | 4 |, }, }, ];","title":"Update"},{"location":"documentation/update/#operators","text":"Inc - inc{...} Set - set{...}","title":"Operators:"},{"location":"documentation/update/#example","text":"Input: collection | test |: q [ find [ gt { value | num |: n | 5 |, }, ], update [ set { value | num |: n | 1000 |, }, ], ]; Output: result : ok [ response { s | data |: ids [ test | 4339ace2-9ab3-4c79-b557-f9b78d66b7f9 |, test | 3677c916-ac4d-40ab-89f4-def1e565e7ab |, test | 5ff00377-34ac-43b9-8ebb-71bb5ff78ebf |, test | 7bdd7c8f-e9da-42f6-b473-5a6fd9a1c90f |, ], s | meta |: update_meta { s | count |: n | 4 |, }, }, ];","title":"Example"},{"location":"tutorial/native/","text":"In this tutorial I'll create a database for the candy store to show the basic AnnaDB features. Insert primitive let's start with categories. Let's represent categories as simple string objects. To do so let's insert the first one into the categories collection. Request : collection | categories |: insert [ s | sweets |, ]; collection|categories| shows on which collection the query will be applied. In our case - categories insert[...] - is a query step. You can insert one or many objects using the insert operation. s|sweets| - is the object to insert. In this case, it is a string primitive. Prefix s means that it is a string, | wrap the value of the primitive. Other primitive types could be found in the Data Types section . Response : result : ok [ response { s | data |: ids [ categories | 285c6e94-0065-49a1-af9b-cb0b60556098 |, ], s | meta |: insert_meta { s | count |: n | 1 |, }, }, ]; If everything is ok, in result will be returned ok[...] vector with responses for all the transaction pipelines. Each response contains data and meta information. In our case there is only one response with a vector of ids in data and a number of inserted objects in meta Insert container Let's insert a more complicated object now - a chocolate bar. It will have fields: name price category For the category, I'll use the already created one. Request : collection | products |: insert [ m { s | name |: s | Tony's |, s | price |: n | 5.95 |, s | category |: categories | 285c6e94-0065-49a1-af9b-cb0b60556098 |, }, ]; The query is similar to the previous one, but the object is not a primitive, but a map. The value of the category field is a link, that was received after the previous insert. Response : result : ok [ response { s | data |: ids [ products | 3d235f3f-4013-492e-b2a4-5ec3dd8ed530 |, ], s | meta |: insert_meta { s | count |: n | 1 |, }, }, ]; The response is nearly the same as before - link in data and number of inserted objects in meta. Get object Let's retrieve the information about this chocolate bar now. I'll use the get operation for this, to the object by id Request : collection | products |: get [ products | 3d235f3f-4013-492e-b2a4-5ec3dd8ed530 |, ]; This time I use the get[...] query step. Using this step you can retrieve one or many objects using object links. Response : result : ok [ response { s | data |: objects { products | 3d235f3f-4013-492e-b2a4-5ec3dd8ed530 |: m { s | category |: s | sweets |, s | price |: n | 5.95 |, s | name |: s | Tony's |, }, }, s | meta |: get_meta { s | count |: n | 1 |, }, }, ]; In the response here you can see the objects{...} map, where keys are links to objects and values are objects. objects{} map keeps the order - it will return objects in the same order as they were requested in the get step, or as they were sorted by the sort step. The category was fetched automatically and the value was returned. Let's insert another chocolate bar there to have more objects in the collection: collection | products |: insert [ m { s | name |: s | Mars |, s | price |: n | 2 |, s | category |: categories | 285c6e94-0065-49a1-af9b-cb0b60556098 |, }, ]; I use the same category id for this bar. Modify primitive Let's modify the category to make it more accurate. Request : collection | categories |: q [ get [ categories | 285c6e94-0065-49a1-af9b-cb0b60556098 |, ], update [ set { root : s | chocolate |, }, ], ]; The query here consists of 2 steps. Get the object by link step and modify this object step. The update[...] operation is a vector of update operators. Read more about the update . Response : result : ok [ response { s | data |: ids [ categories | 285c6e94-0065-49a1-af9b-cb0b60556098 |, ], s | meta |: update_meta { s | count |: n | 1 |, }, }, ]; The response of the update operation contains the ids of the updated objects as data and the number of the updated objects as meta. Let's take a look, at how this affected the chocolate objects. Request : collection | products |: find [ ]; To find objects I use the find[...] operation. It is a vector of find operators. If it is empty, all the collection objects will be returned. Response : result : ok [ response { s | data |: objects { products | c41a98cc-d21a-4ea9-b7d3-011e90e376d3 |: m { s | name |: s | Mars |, s | price |: n | 2 |, s | category |: s | chocolate |, }, products | 3d235f3f-4013-492e-b2a4-5ec3dd8ed530 |: m { s | name |: s | Tony's |, s | price |: n | 5.95 |, s | category |: s | chocolate |, }, }, s | meta |: find_meta { s | count |: n | 2 |, }, }, ]; The category was changed for both products, as the category object was linked with these objects. Modify container Now I'll increase the price of the bars, where it is less than 2 Request : collection | products |: q [ find [ lt { value | price |: n | 3 |, }, ], update [ inc { value | price |: n | 2 |, }, ], ]; The find step can stay before the update step as well. All the found objects will be updated. Read more about find operation and operators here . Response : result : ok [ response { s | data |: ids [ products | c41a98cc-d21a-4ea9-b7d3-011e90e376d3 |, ], s | meta |: update_meta { s | count |: n | 1 |, }, }, ]; The response is similar to the previous one. Here is how all the products look like after update: result : ok [ response { s | data |: objects { products | c41a98cc-d21a-4ea9-b7d3-011e90e376d3 |: m { s | name |: s | Mars |, s | category |: s | chocolate |, s | price |: n | 4 |, }, products | 3d235f3f-4013-492e-b2a4-5ec3dd8ed530 |: m { s | name |: s | Tony's |, s | category |: s | chocolate |, s | price |: n | 5.95 |, }, }, s | meta |: find_meta { s | count |: n | 2 |, }, }, ]; Sort objects To sort objects I'll use the sort operation against the price field Request : collection | products |: q [ find [ ], sort [ asc ( value | price |), ], ]; The sort[...] operation is a vector of sort operators - asc and desc . Sort operators are modifiers, that contain paths to the sorting value. The sort operation is not an independent step, it can stay only after find-like operations, that return objects. You can read more about sort here Response : result : ok [ response { s | data |: objects { products | c41a98cc-d21a-4ea9-b7d3-011e90e376d3 |: m { s | name |: s | Mars |, s | price |: n | 4 |, s | category |: s | chocolate |, }, products | 3d235f3f-4013-492e-b2a4-5ec3dd8ed530 |: m { s | price |: n | 5.95 |, s | name |: s | Tony's |, s | category |: s | chocolate |, }, }, s | meta |: find_meta { s | count |: n | 2 |, }, }, ]; Objects in the response are sorted by price now. It is useful to use limit and offset operations together with sort. You can read about them in the documentation Delete objects You can use delete operation after any find-like step to delete all the found objects. Or it can be used independently to delete the whole collection. Request : collection | products |: q [ find [ gt { value | price |: n | 5 |, }, ], delete , ]; The delete operation is a primitive without value. Response : result : ok [ response { s | data |: ids [ products | 3d235f3f-4013-492e-b2a4-5ec3dd8ed530 |, ], s | meta |: update_meta { s | count |: n | 1 |, }, }, ]; The response contains affected ids in data and the number of deleted objects in meta","title":"Native"},{"location":"tutorial/native/#insert-primitive","text":"let's start with categories. Let's represent categories as simple string objects. To do so let's insert the first one into the categories collection. Request : collection | categories |: insert [ s | sweets |, ]; collection|categories| shows on which collection the query will be applied. In our case - categories insert[...] - is a query step. You can insert one or many objects using the insert operation. s|sweets| - is the object to insert. In this case, it is a string primitive. Prefix s means that it is a string, | wrap the value of the primitive. Other primitive types could be found in the Data Types section . Response : result : ok [ response { s | data |: ids [ categories | 285c6e94-0065-49a1-af9b-cb0b60556098 |, ], s | meta |: insert_meta { s | count |: n | 1 |, }, }, ]; If everything is ok, in result will be returned ok[...] vector with responses for all the transaction pipelines. Each response contains data and meta information. In our case there is only one response with a vector of ids in data and a number of inserted objects in meta","title":"Insert primitive"},{"location":"tutorial/native/#insert-container","text":"Let's insert a more complicated object now - a chocolate bar. It will have fields: name price category For the category, I'll use the already created one. Request : collection | products |: insert [ m { s | name |: s | Tony's |, s | price |: n | 5.95 |, s | category |: categories | 285c6e94-0065-49a1-af9b-cb0b60556098 |, }, ]; The query is similar to the previous one, but the object is not a primitive, but a map. The value of the category field is a link, that was received after the previous insert. Response : result : ok [ response { s | data |: ids [ products | 3d235f3f-4013-492e-b2a4-5ec3dd8ed530 |, ], s | meta |: insert_meta { s | count |: n | 1 |, }, }, ]; The response is nearly the same as before - link in data and number of inserted objects in meta.","title":"Insert container"},{"location":"tutorial/native/#get-object","text":"Let's retrieve the information about this chocolate bar now. I'll use the get operation for this, to the object by id Request : collection | products |: get [ products | 3d235f3f-4013-492e-b2a4-5ec3dd8ed530 |, ]; This time I use the get[...] query step. Using this step you can retrieve one or many objects using object links. Response : result : ok [ response { s | data |: objects { products | 3d235f3f-4013-492e-b2a4-5ec3dd8ed530 |: m { s | category |: s | sweets |, s | price |: n | 5.95 |, s | name |: s | Tony's |, }, }, s | meta |: get_meta { s | count |: n | 1 |, }, }, ]; In the response here you can see the objects{...} map, where keys are links to objects and values are objects. objects{} map keeps the order - it will return objects in the same order as they were requested in the get step, or as they were sorted by the sort step. The category was fetched automatically and the value was returned. Let's insert another chocolate bar there to have more objects in the collection: collection | products |: insert [ m { s | name |: s | Mars |, s | price |: n | 2 |, s | category |: categories | 285c6e94-0065-49a1-af9b-cb0b60556098 |, }, ]; I use the same category id for this bar.","title":"Get object"},{"location":"tutorial/native/#modify-primitive","text":"Let's modify the category to make it more accurate. Request : collection | categories |: q [ get [ categories | 285c6e94-0065-49a1-af9b-cb0b60556098 |, ], update [ set { root : s | chocolate |, }, ], ]; The query here consists of 2 steps. Get the object by link step and modify this object step. The update[...] operation is a vector of update operators. Read more about the update . Response : result : ok [ response { s | data |: ids [ categories | 285c6e94-0065-49a1-af9b-cb0b60556098 |, ], s | meta |: update_meta { s | count |: n | 1 |, }, }, ]; The response of the update operation contains the ids of the updated objects as data and the number of the updated objects as meta. Let's take a look, at how this affected the chocolate objects. Request : collection | products |: find [ ]; To find objects I use the find[...] operation. It is a vector of find operators. If it is empty, all the collection objects will be returned. Response : result : ok [ response { s | data |: objects { products | c41a98cc-d21a-4ea9-b7d3-011e90e376d3 |: m { s | name |: s | Mars |, s | price |: n | 2 |, s | category |: s | chocolate |, }, products | 3d235f3f-4013-492e-b2a4-5ec3dd8ed530 |: m { s | name |: s | Tony's |, s | price |: n | 5.95 |, s | category |: s | chocolate |, }, }, s | meta |: find_meta { s | count |: n | 2 |, }, }, ]; The category was changed for both products, as the category object was linked with these objects.","title":"Modify primitive"},{"location":"tutorial/native/#modify-container","text":"Now I'll increase the price of the bars, where it is less than 2 Request : collection | products |: q [ find [ lt { value | price |: n | 3 |, }, ], update [ inc { value | price |: n | 2 |, }, ], ]; The find step can stay before the update step as well. All the found objects will be updated. Read more about find operation and operators here . Response : result : ok [ response { s | data |: ids [ products | c41a98cc-d21a-4ea9-b7d3-011e90e376d3 |, ], s | meta |: update_meta { s | count |: n | 1 |, }, }, ]; The response is similar to the previous one. Here is how all the products look like after update: result : ok [ response { s | data |: objects { products | c41a98cc-d21a-4ea9-b7d3-011e90e376d3 |: m { s | name |: s | Mars |, s | category |: s | chocolate |, s | price |: n | 4 |, }, products | 3d235f3f-4013-492e-b2a4-5ec3dd8ed530 |: m { s | name |: s | Tony's |, s | category |: s | chocolate |, s | price |: n | 5.95 |, }, }, s | meta |: find_meta { s | count |: n | 2 |, }, }, ];","title":"Modify container"},{"location":"tutorial/native/#sort-objects","text":"To sort objects I'll use the sort operation against the price field Request : collection | products |: q [ find [ ], sort [ asc ( value | price |), ], ]; The sort[...] operation is a vector of sort operators - asc and desc . Sort operators are modifiers, that contain paths to the sorting value. The sort operation is not an independent step, it can stay only after find-like operations, that return objects. You can read more about sort here Response : result : ok [ response { s | data |: objects { products | c41a98cc-d21a-4ea9-b7d3-011e90e376d3 |: m { s | name |: s | Mars |, s | price |: n | 4 |, s | category |: s | chocolate |, }, products | 3d235f3f-4013-492e-b2a4-5ec3dd8ed530 |: m { s | price |: n | 5.95 |, s | name |: s | Tony's |, s | category |: s | chocolate |, }, }, s | meta |: find_meta { s | count |: n | 2 |, }, }, ]; Objects in the response are sorted by price now. It is useful to use limit and offset operations together with sort. You can read about them in the documentation","title":"Sort objects"},{"location":"tutorial/native/#delete-objects","text":"You can use delete operation after any find-like step to delete all the found objects. Or it can be used independently to delete the whole collection. Request : collection | products |: q [ find [ gt { value | price |: n | 5 |, }, ], delete , ]; The delete operation is a primitive without value. Response : result : ok [ response { s | data |: ids [ products | 3d235f3f-4013-492e-b2a4-5ec3dd8ed530 |, ], s | meta |: update_meta { s | count |: n | 1 |, }, }, ]; The response contains affected ids in data and the number of deleted objects in meta","title":"Delete objects"},{"location":"tutorial/python/","text":"In this tutorial, I'll create a database for the candy store to show the basic AnnaDB features. Connect The Connection class is used to connect to the AnnaDB from annadb import Connection conn = Connection . from_connection_string ( \"annadb://localhost:10001\" ) Insert primitive let's start with categories. Let's represent categories as simple string objects. To do so let's insert the first one into the categories collection. Request : ... categories = conn [ \"categories\" ] response = categories . insert_one ( \"sweets\" ) . run () There are two insert operators - insert and insert_one . insert - operator to insert one or many objects. Response data is a list of links (ids). Meta - number of inserted items. insert_one - operator to insert a single object. Response data is a link. Let's get the inserted id ... sweets_id = response . data Insert container Let's insert a more complicated object now - a chocolate bar. It will have fields: name price category For the category, I'll use the already created one. Request : products = conn [ \"products\" ] response = products . insert_one ( { \"name\" : \"Tony's\" , \"price\" : 5.95 , \"category\" : sweets_id } ) tony_id = response . data The query is similar to the previous one, but the object is not a str, but a dict. The value of the category field is a link, that was received after the previous insert. Get object Let's retrieve the information about this chocolate bar now. There are two ways to get objects by link: get and get_one . You can pass any number of links to the get operator. It will return an ordered dict of the link-object pars. get_one operator is used to get a single object. Request : ... response = products . get_one ( tony_id ) . run () print ( response . data [ \"category\" ]) >> > sweets The category was fetched automatically and the value was returned. Let's insert another chocolate bar there to have more objects in the collection: ... response = products . insert_one ( { \"name\" : \"Mars\" , \"price\" : 2 , \"category\" : sweets_id } ) . run () mars_id = response . data I use the same category id for this bar. Modify primitive Let's modify the category to make it more accurate. Request : from annadb import Set , root categories . get ( sweets_id ) . update ( Set ({ root : \"chocolate\" })) . run () The query here consists of 2 steps. Get the object by link step and modify this object step. The root object is a pointer to the value to update. For Vector and Map object it works a starting point in the path like root.path.to.value Let's take a look, at how this affected the chocolate objects. Request : response = products . all () . run () for k , v in response . data . items (): print ( v [ \"category\" ]) >>> chocolate >>> chocolate The category was changed for both products, as the category object was linked with these objects. Modify container Now I'll increase the price of the bars, where it is less than 2 from annadb import Inc products . find ( root . price < 3 ) . update ( Inc ({ root . price : 2 })) . run () The find step can stay before the update step as well. All the found objects will be updated. Let's check the prices now: ... response = products . all () . run () for k , v in response . data . items (): print ( v [ \"name\" ], v [ \"price\" ]) >>> Tony 's 5.95 >>> Mars 4.0 Sort objects To sort objects I'll use the sort operation against the price field Request : response = products . all () . sort ( + root . price ) . run () for k , v in response . data . items (): print ( v [ \"name\" ], v [ \"price\" ]) >>> Mars 4.0 >>> Tony 's 5.95 Objects in the response are sorted by price now. It is useful to use limit and offset operations together with sort. You can read about them in the documentation Delete objects You can use the delete operation after any find-like step to delete all the found objects. Or it can be used independently to delete the whole collection. Request : products . find ( root . price < 5 ) . delete () . run ()","title":"Python"},{"location":"tutorial/python/#connect","text":"The Connection class is used to connect to the AnnaDB from annadb import Connection conn = Connection . from_connection_string ( \"annadb://localhost:10001\" )","title":"Connect"},{"location":"tutorial/python/#insert-primitive","text":"let's start with categories. Let's represent categories as simple string objects. To do so let's insert the first one into the categories collection. Request : ... categories = conn [ \"categories\" ] response = categories . insert_one ( \"sweets\" ) . run () There are two insert operators - insert and insert_one . insert - operator to insert one or many objects. Response data is a list of links (ids). Meta - number of inserted items. insert_one - operator to insert a single object. Response data is a link. Let's get the inserted id ... sweets_id = response . data","title":"Insert primitive"},{"location":"tutorial/python/#insert-container","text":"Let's insert a more complicated object now - a chocolate bar. It will have fields: name price category For the category, I'll use the already created one. Request : products = conn [ \"products\" ] response = products . insert_one ( { \"name\" : \"Tony's\" , \"price\" : 5.95 , \"category\" : sweets_id } ) tony_id = response . data The query is similar to the previous one, but the object is not a str, but a dict. The value of the category field is a link, that was received after the previous insert.","title":"Insert container"},{"location":"tutorial/python/#get-object","text":"Let's retrieve the information about this chocolate bar now. There are two ways to get objects by link: get and get_one . You can pass any number of links to the get operator. It will return an ordered dict of the link-object pars. get_one operator is used to get a single object. Request : ... response = products . get_one ( tony_id ) . run () print ( response . data [ \"category\" ]) >> > sweets The category was fetched automatically and the value was returned. Let's insert another chocolate bar there to have more objects in the collection: ... response = products . insert_one ( { \"name\" : \"Mars\" , \"price\" : 2 , \"category\" : sweets_id } ) . run () mars_id = response . data I use the same category id for this bar.","title":"Get object"},{"location":"tutorial/python/#modify-primitive","text":"Let's modify the category to make it more accurate. Request : from annadb import Set , root categories . get ( sweets_id ) . update ( Set ({ root : \"chocolate\" })) . run () The query here consists of 2 steps. Get the object by link step and modify this object step. The root object is a pointer to the value to update. For Vector and Map object it works a starting point in the path like root.path.to.value Let's take a look, at how this affected the chocolate objects. Request : response = products . all () . run () for k , v in response . data . items (): print ( v [ \"category\" ]) >>> chocolate >>> chocolate The category was changed for both products, as the category object was linked with these objects.","title":"Modify primitive"},{"location":"tutorial/python/#modify-container","text":"Now I'll increase the price of the bars, where it is less than 2 from annadb import Inc products . find ( root . price < 3 ) . update ( Inc ({ root . price : 2 })) . run () The find step can stay before the update step as well. All the found objects will be updated. Let's check the prices now: ... response = products . all () . run () for k , v in response . data . items (): print ( v [ \"name\" ], v [ \"price\" ]) >>> Tony 's 5.95 >>> Mars 4.0","title":"Modify container"},{"location":"tutorial/python/#sort-objects","text":"To sort objects I'll use the sort operation against the price field Request : response = products . all () . sort ( + root . price ) . run () for k , v in response . data . items (): print ( v [ \"name\" ], v [ \"price\" ]) >>> Mars 4.0 >>> Tony 's 5.95 Objects in the response are sorted by price now. It is useful to use limit and offset operations together with sort. You can read about them in the documentation","title":"Sort objects"},{"location":"tutorial/python/#delete-objects","text":"You can use the delete operation after any find-like step to delete all the found objects. Or it can be used independently to delete the whole collection. Request : products . find ( root . price < 5 ) . delete () . run ()","title":"Delete objects"}]}